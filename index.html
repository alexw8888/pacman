<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Pac-Man Clone</title>
    <style>
        body {
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
            color: white;
        }

        canvas {
            border: 2px solid #555;
            box-shadow: 0 0 20px rgba(0, 0, 255, 0.2);
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 20px;
        }
    </style>
</head>

<body>
    <div id="ui">Score: <span id="score">0</span> &nbsp; Lives: <span id="lives">10</span></div>
    <canvas id="gameCanvas"></canvas>

    <script>
        // --- Constants ---
        const TILE_SIZE = 16;
        const GRID_WIDTH = 28;
        const GRID_HEIGHT = 31;
        const CANVAS_WIDTH = GRID_WIDTH * TILE_SIZE;   // 448
        const CANVAS_HEIGHT = GRID_HEIGHT * TILE_SIZE; // 496

        // Directions
        const NONE = 0;
        const UP = 1;
        const DOWN = 2;
        const LEFT = 3;
        const RIGHT = 4;

        // Tile Types
        const WALL = 0;
        const PELLET = 1;
        const POWER_PELLET = 2;
        const EMPTY = 3;
        const GATE = 4; // Ghost house gate

        // Colors
        const COLOR_WALL = '#1919A6'; // Classic Blue
        const COLOR_PELLET = '#FFB897';
        const COLOR_PACMAN = '#FFFF00';
        const COLOR_BG = '#000000';

        // --- RPG Constants ---
        const XP_PER_PELLET = 10;
        const XP_PER_GHOST = 200;
        const BASE_XP_TO_LEVEL = 500;
        const XP_SCALAR = 1.2; // Increase XP requirement by 20% each level


        // --- Map Data (Classic-ish Layout) ---
        // 0: Wall, 1: Pellet, 2: Power, 3: Empty, 4: Gate
        // 28 cols x 31 rows
        const INITIAL_MAP_LAYOUT = [
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
            [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0],
            [0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0],
            [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0],
            [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
            [0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0],
            [0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0],
            [0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0],
            [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
            [3, 3, 3, 3, 3, 0, 1, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 0, 1, 0, 3, 3, 3, 3, 3],
            [3, 3, 3, 3, 3, 0, 1, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 1, 0, 3, 3, 3, 3, 3],
            [3, 3, 3, 3, 3, 0, 1, 0, 0, 3, 0, 0, 4, 4, 4, 4, 0, 0, 3, 0, 0, 1, 0, 3, 3, 3, 3, 3], // 4 is Gate
            [0, 0, 0, 0, 0, 0, 1, 0, 0, 3, 0, 3, 3, 3, 3, 3, 3, 0, 3, 0, 0, 1, 0, 0, 0, 0, 0, 0],
            [3, 3, 3, 3, 3, 3, 1, 3, 3, 3, 0, 3, 3, 3, 3, 3, 3, 0, 3, 3, 3, 1, 3, 3, 3, 3, 3, 3], // Tunnel row (index 14)
            [0, 0, 0, 0, 0, 0, 1, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 1, 0, 0, 0, 0, 0, 0],
            [3, 3, 3, 3, 3, 0, 1, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 1, 0, 3, 3, 3, 3, 3],
            [3, 3, 3, 3, 3, 0, 1, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 1, 0, 3, 3, 3, 3, 3],
            [0, 0, 0, 0, 0, 0, 1, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 1, 0, 0, 0, 0, 0, 0],
            [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
            [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0],
            [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0],
            [0, 2, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 3, 3, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 2, 0], // Pacman spawn around here
            [0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0],
            [0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0],
            [0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0],
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
            [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] // bottom row buffer
        ];

        // --- Core Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');

        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        // --- Classes ---

        class InputHandler {
            constructor() {
                this.lastKeyPressed = NONE;
                this.mouseX = 0;
                this.mouseY = 0;
                this.mouseClicked = false;

                this.keys = {}; // Track all keys

                window.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    switch (e.code) {
                        case 'ArrowUp': this.lastKeyPressed = UP; break;
                        case 'ArrowDown': this.lastKeyPressed = DOWN; break;
                        case 'ArrowLeft': this.lastKeyPressed = LEFT; break;
                        case 'ArrowRight': this.lastKeyPressed = RIGHT; break;
                    }
                });

                window.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });

                // Mouse Handling for UI
                const canvas = document.getElementById('gameCanvas');
                canvas.addEventListener('mousemove', (e) => {
                    const rect = canvas.getBoundingClientRect();
                    this.mouseX = e.clientX - rect.left;
                    this.mouseY = e.clientY - rect.top;
                });

                canvas.addEventListener('click', () => {
                    this.mouseClicked = true;
                });
            }

            getDirection() {
                return this.lastKeyPressed;
            }

            getMouseStatus() {
                const status = { x: this.mouseX, y: this.mouseY, clicked: this.mouseClicked };
                this.mouseClicked = false; // Reset click
                return status;
            }

            isKeyDown(code) {
                return !!this.keys[code];
            }
        }

        class AudioController {
            constructor() {
                try {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) { console.log('Audio not supported'); }
            }

            playTone(freq, type, duration) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            }

            playChomp() { this.playTone(150, 'triangle', 0.1); }
            playEatGhost() { this.playTone(600, 'square', 0.2); }
            playDie() {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.frequency.setValueAtTime(400, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(50, this.ctx.currentTime + 1);
                gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 1);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 1);
            }
        }

        class Map {
            constructor(layout) {
                this.layout = layout;
            }

            draw(ctx) {
                for (let r = 0; r < GRID_HEIGHT; r++) {
                    for (let c = 0; c < GRID_WIDTH; c++) {
                        let tile = this.layout[r][c];
                        let x = c * TILE_SIZE;
                        let y = r * TILE_SIZE;

                        if (tile === WALL) {
                            // Fancy "Double Line" logic
                            // Actually, let's just draw Blue borders where there is NO neighbor wall
                            ctx.strokeStyle = COLOR_WALL;
                            ctx.lineWidth = 2;
                            ctx.lineCap = 'round';

                            // Check neighbors
                            let nUp = (r > 0) ? this.layout[r - 1][c] : -1;
                            let nDown = (r < GRID_HEIGHT - 1) ? this.layout[r + 1][c] : -1;
                            let nLeft = (c > 0) ? this.layout[r][c - 1] : -1;
                            let nRight = (c < GRID_WIDTH - 1) ? this.layout[r][c + 1] : -1;

                            // If neighbor is NOT Wall (can be Gate), draw line
                            // Double line offset
                            const off = 4;

                            const isWallOrGate = (t) => t === WALL || t === GATE;

                            // Draw outer ring
                            ctx.beginPath();
                            if (!isWallOrGate(nUp)) { ctx.moveTo(x, y + off); ctx.lineTo(x + TILE_SIZE, y + off); }
                            if (!isWallOrGate(nDown)) { ctx.moveTo(x, y + TILE_SIZE - off); ctx.lineTo(x + TILE_SIZE, y + TILE_SIZE - off); }
                            if (!isWallOrGate(nLeft)) { ctx.moveTo(x + off, y); ctx.lineTo(x + off, y + TILE_SIZE); }
                            if (!isWallOrGate(nRight)) { ctx.moveTo(x + TILE_SIZE - off, y); ctx.lineTo(x + TILE_SIZE - off, y + TILE_SIZE); }
                            ctx.stroke();

                            // To make it look connected we need corners... this is getting complex for procedural.
                            // Fallback to "Connected Skeleton"
                            // Draw a Blue Square
                            // Draw a slightly smaller Black Square
                            // "Connect" the black squares if neighbors are walls

                            // 1. Blue Base
                            // Removed: we only want lines.

                            // Let's try the "Hollow Tube" method again but refined.
                            // Fill Blue
                            // Fill Black Center (smaller)
                            // Fill Black Extensions to neighbors

                            ctx.fillStyle = COLOR_WALL;
                            ctx.fillRect(x + 3, y + 3, TILE_SIZE - 6, TILE_SIZE - 6); // Small blue pivot

                            // Extend blue to neighbors
                            if (isWallOrGate(nUp)) ctx.fillRect(x + 3, y, TILE_SIZE - 6, 6);
                            if (isWallOrGate(nDown)) ctx.fillRect(x + 3, y + TILE_SIZE - 6, TILE_SIZE - 6, 6);
                            if (isWallOrGate(nLeft)) ctx.fillRect(x, y + 3, 6, TILE_SIZE - 6);
                            if (isWallOrGate(nRight)) ctx.fillRect(x + TILE_SIZE - 6, y + 3, 6, TILE_SIZE - 6);

                            // Now cut out the center black
                            ctx.fillStyle = 'black';
                            ctx.fillRect(x + 5, y + 5, TILE_SIZE - 10, TILE_SIZE - 10);

                            // Extend black cutout
                            if (isWallOrGate(nUp)) ctx.fillRect(x + 5, y, TILE_SIZE - 10, 5);
                            if (isWallOrGate(nDown)) ctx.fillRect(x + 5, y + TILE_SIZE - 5, TILE_SIZE - 10, 6); // slight overlap
                            if (isWallOrGate(nLeft)) ctx.fillRect(x, y + 5, 5, TILE_SIZE - 10);
                            if (isWallOrGate(nRight)) ctx.fillRect(x + TILE_SIZE - 5, y + 5, 6, TILE_SIZE - 10);

                        } else if (tile === PELLET) {
                            ctx.fillStyle = COLOR_PELLET;
                            ctx.fillRect(x + 7, y + 7, 2, 2); // Smaller pellet
                        } else if (tile === POWER_PELLET) {
                            ctx.fillStyle = COLOR_PELLET;
                            ctx.beginPath();
                            ctx.arc(x + 8, y + 8, 6, 0, Math.PI * 2);
                            ctx.fill();
                        } else if (tile === GATE) {
                            ctx.fillStyle = 'pink';
                            ctx.fillRect(x, y + 7, TILE_SIZE, 2);
                        }
                    }
                }
            }

            isWall(r, c) {
                if (r < 0 || r >= GRID_HEIGHT || c < 0 || c >= GRID_WIDTH) return true; // Bounds check
                return this.layout[r][c] === WALL;
            }

            isGate(r, c) {
                if (r < 0 || r >= GRID_HEIGHT || c < 0 || c >= GRID_WIDTH) return false;
                return this.layout[r][c] === GATE;
            }
        }

        class Pacman {
            constructor(startX, startY, map, game) {
                this.x = startX * TILE_SIZE;
                this.y = startY * TILE_SIZE;
                this.speed = 2; // Pixels per frame
                this.currentDir = NONE;
                this.nextDir = NONE;
                this.map = map;
                this.game = game; // Store reference to game instance
                this.mouthOpen = 0;
                this.mouthSpeed = 0.1;
            }

            update(inputDir) {
                if (inputDir !== NONE) {
                    this.nextDir = inputDir;
                }

                // Try to turn
                if (this.nextDir !== NONE && this.canMove(this.nextDir)) {
                    // Only turn if perfectly aligned with grid, OR if we are currently stopped (so we can start moving)
                    if ((this.x % TILE_SIZE === 0 && this.y % TILE_SIZE === 0) || this.currentDir === NONE) {
                        this.currentDir = this.nextDir;
                        this.nextDir = NONE;
                    }
                }

                if (this.canMove(this.currentDir)) {
                    switch (this.currentDir) {
                        case UP: this.y -= this.speed; break;
                        case DOWN: this.y += this.speed; break;
                        case LEFT: this.x -= this.speed; break;
                        case RIGHT: this.x += this.speed; break;
                    }

                    // Wraparound
                    if (this.x < -TILE_SIZE) this.x = CANVAS_WIDTH;
                    if (this.x > CANVAS_WIDTH) this.x = -TILE_SIZE;

                    // Simple animation (mouth)
                    this.mouthOpen += this.mouthSpeed;
                    if (this.mouthOpen > 0.2 || this.mouthOpen < 0) this.mouthSpeed = -this.mouthSpeed;

                    // Audio: Play chomp when mouth closes
                    if (Math.abs(this.mouthOpen) < 0.05 && this.mouthSpeed > 0) {
                        if (this.game && this.game.audio) this.game.audio.playChomp();
                    }

                    // Perk: TRAIL BLAZER
                    if (this.game.perks.includes('trail_blazer')) {
                        const r = Math.round(this.y / TILE_SIZE);
                        const c = Math.round(this.x / TILE_SIZE);
                        if (!this.game.fireTiles.find(f => f.r === r && f.c === c)) {
                            this.game.fireTiles.push({ r, c, life: 4000 });
                        }
                    }

                    // Perk: MAGNETISM
                    if (this.game.perks.includes('magnetism')) {
                        const magRange = 3; // Tiles
                        // Scan area around pacman
                        let centerR = Math.round(this.y / TILE_SIZE);
                        let centerC = Math.round(this.x / TILE_SIZE);

                        for (let r = centerR - magRange; r <= centerR + magRange; r++) {
                            for (let c = centerC - magRange; c <= centerC + magRange; c++) {
                                if (r >= 0 && r < GRID_HEIGHT && c >= 0 && c < GRID_WIDTH) {
                                    if (this.map.layout[r][c] === PELLET || this.map.layout[r][c] === POWER_PELLET) {
                                        // "Pull" visual isn't easy with grid array.
                                        // For now, simpler: Instant eat if effectively close, or just expand eat radius?
                                        // The prompt says "fly toward Pac-Man".
                                        // To do that, we'd need Pellet objects. Currently map is just integers.
                                        // Compromise: Instant eat in radius (Super Magnet).
                                        // Or, convert integer to "FlyingPellet" object ONLY when in range?
                                        // Let's go with "Vacuum Mode": Eat anything in 3 tile radius immediately.
                                        // Actually, let's make it look cool later if time permits. "Vacuum" is functionally "Magnetism" for grid.

                                        // Dist check
                                        let dist = Math.hypot(c * TILE_SIZE - this.x, r * TILE_SIZE - this.y);
                                        if (dist < magRange * TILE_SIZE) {
                                            // Suck it in
                                            let tile = this.map.layout[r][c];
                                            this.map.layout[r][c] = EMPTY;
                                            if (tile === PELLET) this.game.pelletEaten(10);
                                            if (tile === POWER_PELLET) {
                                                this.game.pelletEaten(50);
                                                this.game.activatePowerMode();
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                    // Eat Pellets (Standard Collision)
                    // Check overlap
                    // Center of pacman vs center of tile
                    if (this.x % TILE_SIZE === 0 && this.y % TILE_SIZE === 0) {
                        let r = this.y / TILE_SIZE;
                        let c = this.x / TILE_SIZE;
                        let tile = this.map.layout[r][c];
                        if (tile === PELLET) {
                            this.map.layout[r][c] = EMPTY;
                            this.game.pelletEaten(10);
                        } else if (tile === POWER_PELLET) {
                            this.map.layout[r][c] = EMPTY;
                            this.game.pelletEaten(50);
                            this.game.activatePowerMode();
                        }
                    }
                }
            }


            canMove(direction) {
                let r = Math.floor(this.y / TILE_SIZE);
                let c = Math.floor(this.x / TILE_SIZE);

                // If not aligned, can only continue in current axis?
                // Actually simplified: check the tile ahead.
                // We need more precise collision to avoid wall clipping.
                // Assuming speed fits into TILE_SIZE (16 % 2 == 0), we check grid alignment.

                let nextR = r;
                let nextC = c;

                if (this.x % TILE_SIZE !== 0 || this.y % TILE_SIZE !== 0) {
                    // Mid-tile, can only continue if direction matches axis
                    if (direction === UP || direction === DOWN) {
                        return (this.x % TILE_SIZE === 0);
                    }
                    if (direction === LEFT || direction === RIGHT) {
                        return (this.y % TILE_SIZE === 0);
                    }
                }

                if (direction === UP) nextR--;
                if (direction === DOWN) nextR++;
                if (direction === LEFT) nextC--;
                if (direction === RIGHT) nextC++;

                if (this.map.isWall(nextR, nextC) || this.map.isGate(nextR, nextC)) {
                    return false;
                }
                return true;
            }

            draw(ctx) {
                ctx.fillStyle = COLOR_PACMAN;
                ctx.beginPath();

                let cx = this.x + TILE_SIZE / 2;
                let cy = this.y + TILE_SIZE / 2;
                let angle = 0;
                if (this.currentDir === UP) angle = -Math.PI / 2;
                if (this.currentDir === DOWN) angle = Math.PI / 2;
                if (this.currentDir === LEFT) angle = Math.PI; // Flip
                if (this.currentDir === RIGHT) angle = 0;

                // Arc
                // If LEFT, 180 deg. Math.PI. 
                // Draw arc from angle + mouth to angle + 2PI - mouth

                let mouth = (this.currentDir === NONE) ? 0 : Math.abs(this.mouthOpen);

                ctx.arc(cx, cy, TILE_SIZE / 2 - 2, angle + mouth * Math.PI, angle + (2 - mouth) * Math.PI);
                ctx.lineTo(cx, cy);
                ctx.fill();
            }
        }

        class Ghost {
            constructor(x, y, color, type, map) {
                this.x = x * TILE_SIZE;
                this.y = y * TILE_SIZE;
                this.color = color;
                this.type = type; // 0: Red, 1: Pink, 2: Cyan, 3: Orange
                this.map = map;
                this.speed = 1; // Normal speed
                this.dir = NONE;
                this.nextDir = NONE;
                // Mode: SCATTER, CHASE, FRIGHTENED, EATEN, HOUSE, EXITING
                this.mode = 'HOUSE';
                // Initial direction inside house (VERTICAL)
                this.dir = [UP, DOWN][Math.floor(Math.random() * 2)];
                this.speedAccumulator = 0;
            }

            update(targetX, targetY) {
                // Wraparound
                if (this.x < -TILE_SIZE) this.x = CANVAS_WIDTH;
                if (this.x > CANVAS_WIDTH) this.x = -TILE_SIZE;

                let currentSpeed = this.speed;
                if (this.mode === 'EATEN') currentSpeed = 4; // Fast eyes
                else if (this.mode === 'FRIGHTENED') currentSpeed = 0.5;

                this.speedAccumulator += currentSpeed;

                while (this.speedAccumulator >= 1) {
                    this.moveStep(targetX, targetY);
                    this.speedAccumulator -= 1;
                    // Optimization: Snap if crossed tile center? 
                    // Existing logic relies on x % TILE_SIZE === 0 checks.
                    // If we move multiple pixels in one frame, we might skip the exact 0 alignment?
                    // moveStep moves 1 pixel.
                    // If we call it multiple times, we move multiple pixels.
                    // It should be fine as long as we don't overshoot turn points.
                    // But moveStep calls decideDirection only at 0.
                    // If we move 2 pixels from -1 to 1, we skip 0.
                    // We must ensure we hit 0. 
                    // Actually, existing logic:
                    // case UP: this.y -= 1;
                    // decision: if (this.x % TILE_SIZE === 0 ...)

                    // If we step 1 by 1, we will hit 0.
                    // So this loop is safe.
                }
            }

            moveStep(targetX, targetY) {
                // Special State Handling (Check BEFORE move)
                if (this.mode === 'HOUSE') {
                    // Bounce logic (Pixel based)
                    // House Y range approx: 13*16 (208) to 15*16 (240)
                    // Keep between 216 (13.5) and 232 (14.5) approx
                    const minY = 13.5 * TILE_SIZE;
                    const maxY = 14.5 * TILE_SIZE;

                    if (this.dir === UP && this.y <= minY) this.dir = DOWN;
                    else if (this.dir === DOWN && this.y >= maxY) this.dir = UP;
                }
                else if (this.mode === 'EXITING') {
                    // Naviagte to Center X then UP
                    const centerX = 13.5 * TILE_SIZE;
                    const exitY = 11 * TILE_SIZE; // Target outside

                    if (Math.abs(this.x - centerX) > 1) {
                        if (this.x < centerX) this.dir = RIGHT;
                        else this.dir = LEFT;
                    } else {
                        this.x = centerX; // Snap X
                        if (this.y > exitY) this.dir = UP;
                        else {
                            // Exited
                            this.mode = 'SCATTER'; // Or global mode
                            this.dir = LEFT; // Break LEFT usually
                            this.y = exitY; // Snap Y
                        }
                    }
                }

                // Apply Movement
                switch (this.dir) {
                    case UP: this.y -= 1; break;
                    case DOWN: this.y += 1; break;
                    case LEFT: this.x -= 1; break;
                    case RIGHT: this.x += 1; break;
                }

                // Regular Grid Decision (SCATTER, CHASE, FRIGHTENED, EATEN)
                // Only at intersection
                if (this.mode !== 'HOUSE' && this.mode !== 'EXITING') {
                    if (this.x % TILE_SIZE === 0 && this.y % TILE_SIZE === 0) {
                        this.decideDirection(targetX, targetY);
                    }
                }
            }

            decideDirection(targetX, targetY) {
                let validDirs = [];

                // Helper to check validity
                const isValid = (d) => {
                    let nr = this.row();
                    let nc = this.col();
                    if (d === UP) nr--;
                    if (d === DOWN) nr++;
                    if (d === LEFT) nc--;
                    if (d === RIGHT) nc++;

                    // Allow Gate if EATEN (Entering)
                    let isGate = this.map.isGate(nr, nc);
                    if (isGate) {
                        if (this.mode === 'EATEN') return true;
                        return false;
                    }

                    return !this.map.isWall(nr, nc);
                };

                // Check all 4 dirs
                if (isValid(UP) && this.dir !== DOWN) validDirs.push(UP);
                if (isValid(DOWN) && this.dir !== UP) validDirs.push(DOWN);
                if (isValid(LEFT) && this.dir !== RIGHT) validDirs.push(LEFT);
                if (isValid(RIGHT) && this.dir !== LEFT) validDirs.push(RIGHT);

                if (validDirs.length === 0) {
                    // Dead end 
                    if (this.dir === UP) this.dir = DOWN;
                    else if (this.dir === DOWN) this.dir = UP;
                    else if (this.dir === LEFT) this.dir = RIGHT;
                    else if (this.dir === RIGHT) this.dir = LEFT;
                    return;
                }

                // Choose best direction based on target
                let bestDir = validDirs[0];
                let minDist = Infinity;

                // Determine target based on mode
                let tx = targetX;
                let ty = targetY;

                if (this.mode === 'SCATTER') {
                    // scatter to corners
                    if (this.type === 0) { tx = CANVAS_WIDTH - TILE_SIZE; ty = 0; } // Top Right
                    else if (this.type === 1) { tx = 0; ty = 0; } // Top Left
                    else if (this.type === 2) { tx = CANVAS_WIDTH; ty = CANVAS_HEIGHT; } // Bottom Right
                    else if (this.type === 3) { tx = 0; ty = CANVAS_HEIGHT; } // Bottom Left
                } else if (this.mode === 'FRIGHTENED') {
                    // Random
                    this.dir = validDirs[Math.floor(Math.random() * validDirs.length)];
                    return; // Done
                } else if (this.mode === 'EATEN') {
                    // Return to inside house (Center)
                    tx = 13.5 * TILE_SIZE;
                    ty = 14 * TILE_SIZE;

                    // Check if we arrived (approx)
                    // Since EATEN eyes travel on grid, they eventually hit 13.5?
                    // No, grid is integers. 13.5 is half.
                    // Closest integer node is (13,11) index outside gate.
                    // We need EATEN to enter gate (13,12) (which is 13.5?)
                    // Gate is at col 13?
                    // Map: 4,4,4,4. Cols 12,13,14,15.
                    // Center is 13.5.
                    // Target: 13.5 * 16.
                    // Standard logic moves on grid lines.
                    // Eyes should target (13.5, 11) (Outside gate).

                    let homeX = 13.5 * TILE_SIZE;
                    let homeY = 11 * TILE_SIZE; // Just outside gate

                    if (Math.abs(this.x - homeX) < TILE_SIZE && Math.abs(this.y - homeY) < TILE_SIZE) {
                        // Arrived at door, enter house mode or force down?
                        // Let's just revive here for simplicity
                        this.mode = 'SCATTER'; // Instant revive at door
                        return;
                    }

                    tx = homeX;
                    ty = homeY;
                }

                validDirs.forEach(d => {
                    let nextX = this.x + (d === LEFT ? -TILE_SIZE : (d === RIGHT ? TILE_SIZE : 0));
                    let nextY = this.y + (d === UP ? -TILE_SIZE : (d === DOWN ? TILE_SIZE : 0));
                    let dist = Math.hypot(nextX - tx, nextY - ty);
                    if (dist < minDist) {
                        minDist = dist;
                        bestDir = d;
                    }
                });

                this.dir = bestDir;
            }

            row() { return Math.round(this.y / TILE_SIZE); }
            col() { return Math.round(this.x / TILE_SIZE); }

            draw(ctx) {
                ctx.fillStyle = this.mode === 'FRIGHTENED' ? '#0000FF' : (this.mode === 'EATEN' ? 'transparent' : this.color);

                let x = this.x;
                let y = this.y;

                if (this.mode !== 'EATEN') {
                    // Ghost Body ( Dome + Feet)
                    ctx.beginPath();
                    ctx.arc(x + TILE_SIZE / 2, y + TILE_SIZE / 2 - 2, TILE_SIZE / 2 - 2, Math.PI, 0);
                    ctx.lineTo(x + TILE_SIZE - 2, y + TILE_SIZE);
                    ctx.lineTo(x + 2, y + TILE_SIZE);
                    ctx.fill();
                }

                // Eyes (always visible)
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(x + 5, y + 6, 3, 0, Math.PI * 2);
                ctx.arc(x + 11, y + 6, 3, 0, Math.PI * 2);
                ctx.fill();

                // Pupils
                ctx.fillStyle = 'blue';
                ctx.beginPath();
                ctx.arc(x + 5 + (this.dir === RIGHT ? 1 : (this.dir === LEFT ? -1 : 0)), y + 6 + (this.dir === DOWN ? 1 : (this.dir === UP ? -1 : 0)), 1.5, 0, Math.PI * 2);
                ctx.arc(x + 11 + (this.dir === RIGHT ? 1 : (this.dir === LEFT ? -1 : 0)), y + 6 + (this.dir === DOWN ? 1 : (this.dir === UP ? -1 : 0)), 1.5, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class PacmanGame {
            constructor(inputHandler, audioController) {
                this.score = 0;

                // RPG State
                this.level = 1;
                this.xp = 0;
                this.xpMax = BASE_XP_TO_LEVEL;
                this.perks = [];
                this.offeredPerks = [];
                this.fireTiles = [];
                this.projectiles = [];
                this.bulletTimer = 0;

                this.input = inputHandler;
                this.audio = audioController;
                this.map = new Map(JSON.parse(JSON.stringify(INITIAL_MAP_LAYOUT)));
                // Count pellets
                this.pelletCount = 0;
                for (let r = 0; r < GRID_HEIGHT; r++) {
                    for (let c = 0; c < GRID_WIDTH; c++) {
                        if (this.map.layout[r][c] === PELLET || this.map.layout[r][c] === POWER_PELLET) {
                            this.pelletCount++;
                        }
                    }
                }
                this.pacman = new Pacman(13.5, 22, this.map, this);
                this.lives = 3;

                // Fixed spawn definitions to correct tiles
                this.ghosts = [
                    new Ghost(13.5, 11, 'red', 0, this.map), // Blinky (Outside gate)
                    new Ghost(13.5, 14, 'pink', 1, this.map), // Pinky (Inside)
                    new Ghost(11.5, 14, 'cyan', 2, this.map), // Inky (Inside)
                    new Ghost(15.5, 14, 'orange', 3, this.map) // Clyde (Inside)
                ];

                // Initialize Modes
                this.ghosts[0].mode = 'SCATTER';
                this.ghosts[0].dir = [LEFT, RIGHT][Math.floor(Math.random() * 2)]; // Force horizontal
                this.ghosts[1].mode = 'HOUSE';
                this.ghosts[2].mode = 'HOUSE';
                this.ghosts[3].mode = 'HOUSE';

                this.state = 'READY'; // READY, PLAYING, GAMEOVER, LEVEL_UP

                // RPG State
                this.level = 1;
                this.xp = 0;
                this.xpMax = BASE_XP_TO_LEVEL;
                this.perks = [];
                this.offeredPerks = []; // Perls shown in menu

                this.lastTime = 0;
                this.powerMode = false;
                this.powerTimer = 0;

                // Global Scatter/Chase timer
                this.modeTimer = 0;
                this.globalMode = 'SCATTER';

                // Ghost Release Timer
                this.ghostReleaseTimer = 0;
                this.ghostsReleased = 1; // Blinky is out

                // Listen for Start
                window.addEventListener('keydown', (e) => {
                    if (e.code === 'Space') {
                        if (this.state === 'READY' || this.state === 'GAMEOVER') {
                            this.audio.ctx && this.audio.ctx.resume();
                            this.resetGame();
                            this.state = 'PLAYING';
                        }
                    }
                });
            }

            resetGame() {
                this.score = 0;
                document.getElementById('score').innerText = 0;
                this.lives = 3;
                document.getElementById('lives').innerText = this.lives;

                // Reuse level reset logic to restore map and entities
                this.nextLevel();
            }

            addScore(pts) {
                this.score += pts;
                document.getElementById('score').innerText = this.score;
                this.gainXp(pts); // XP matches score usage mostly
            }

            gainXp(amount) {
                if (this.state !== 'PLAYING') return;
                this.xp += amount;
                if (this.xp >= this.xpMax) {
                    this.triggerLevelUp();
                }
            }

            triggerLevelUp() {
                this.state = 'LEVEL_UP';
                this.xp = this.xp - this.xpMax; // Carry over overflow
                this.xpMax = Math.floor(this.xpMax * XP_SCALAR);
                this.level++;
                this.generatePerkOptions();
            }

            generatePerkOptions() {
                // TODO: Populate this.offeredPerks with actual Perk objects
                // For now placeholders
                this.offeredPerks = [
                    { id: 'trail_blazer', name: 'Trail Blazer', desc: 'Leave a trail of fire.' },
                    { id: 'magnetism', name: 'Magnetism', desc: 'Pellets fly to you.' },
                    { id: 'bullet', name: 'Bullet', desc: 'Shoot ghosts automatically.' }
                ];
            }

            selectPerk(perkId) {
                this.perks.push(perkId);
                console.log("Selected perk:", perkId);
                this.state = 'PLAYING';
            }


            pelletEaten(pts) {
                this.addScore(pts);
                this.pelletCount--;
                if (this.pelletCount <= 0) {
                    setTimeout(() => this.nextLevel(), 500);
                }
            }

            nextLevel() {
                // Restore map
                this.map = new Map(JSON.parse(JSON.stringify(INITIAL_MAP_LAYOUT)));

                // Reset Pellet Count
                this.pelletCount = 0;
                for (let r = 0; r < GRID_HEIGHT; r++) {
                    for (let c = 0; c < GRID_WIDTH; c++) {
                        if (this.map.layout[r][c] === PELLET || this.map.layout[r][c] === POWER_PELLET) {
                            this.pelletCount++;
                        }
                    }
                }

                // Reset entities
                this.softReset();

                // Need to re-bind map to pacman and ghosts since map object changed
                this.pacman.map = this.map;
                this.ghosts.forEach(g => g.map = this.map);
            }

            activatePowerMode() {
                this.powerMode = true;
                clearTimeout(this.powerTimer);
                this.powerTimer = setTimeout(() => {
                    this.powerMode = false;
                    this.ghosts.forEach(g => {
                        if (g.mode === 'FRIGHTENED') g.mode = this.globalMode;
                    });
                }, 8000);

                this.ghosts.forEach(g => {
                    // Don't frighten eaten/house ghosts
                    if (g.mode !== 'EATEN' && g.mode !== 'HOUSE' && g.mode !== 'EXITING') g.mode = 'FRIGHTENED';
                });
            }

            init() {
                // No longer starts loop automatically
                // requestAnimationFrame((t) => this.loop(t));
                this.softReset(); // Ensure fresh start
            }

            update(dt) {
                if (this.state === 'LEVEL_UP') {
                    this.updateLevelUp(dt);
                    return; // Pause game world
                }

                if (this.state !== 'PLAYING') return;

                // Ghost Release Logic
                this.ghostReleaseTimer += dt;
                if (this.ghostsReleased < 4 && this.ghostReleaseTimer > 5000) { // Release every 5 seconds
                    // Find a ghost in HOUSE
                    let g = this.ghosts.find(gh => gh.mode === 'HOUSE');
                    if (g) {
                        g.mode = 'EXITING';
                        this.ghostsReleased++;
                        this.ghostReleaseTimer = 0;
                    }
                }

                // Mode switching (7s Scatter / 20s Chase simple loop)
                this.modeTimer += dt;
                if (!this.powerMode) {
                    if (this.globalMode === 'SCATTER' && this.modeTimer > 7000) {
                        this.globalMode = 'CHASE';
                        this.modeTimer = 0;
                        this.ghosts.forEach(g => { if (g.mode !== 'EATEN' && g.mode !== 'FRIGHTENED' && g.mode !== 'HOUSE' && g.mode !== 'EXITING') g.mode = 'CHASE'; });
                    } else if (this.globalMode === 'CHASE' && this.modeTimer > 20000) {
                        this.globalMode = 'SCATTER';
                        this.modeTimer = 0;
                        this.ghosts.forEach(g => { if (g.mode !== 'EATEN' && g.mode !== 'FRIGHTENED' && g.mode !== 'HOUSE' && g.mode !== 'EXITING') g.mode = 'SCATTER'; });
                    }
                }

                // Pacman Update with sound trigger check?
                // We need to pass game to pacman or have pacman return event?
                // Easier: Pacman triggers event or access game singleton.
                // Let's modify Pacman class slightly inside Game updater or just check changes.
                // Or just inject Game into Pacman.

                this.pacman.update(this.input.getDirection());
                this.ghosts.forEach(g => g.update(this.pacman.x, this.pacman.y));

                // Collision
                this.ghosts.forEach(g => {
                    let dist = Math.hypot(g.x - this.pacman.x, g.y - this.pacman.y);
                    if (dist < TILE_SIZE) {
                        if (g.mode === 'FRIGHTENED') {
                            g.mode = 'EATEN';
                            this.addScore(200);
                            this.audio.playEatGhost();
                        } else if (g.mode !== 'EATEN') {
                            this.audio.playDie();
                            this.lives--;
                            document.getElementById('lives').innerText = this.lives;
                            if (this.lives > 0) {
                                this.softReset();
                            } else {
                                this.state = 'GAMEOVER';
                            }
                        }
                    }
                });
                if (this.fireTiles.length > 0) {
                    for (let i = this.fireTiles.length - 1; i >= 0; i--) {
                        let f = this.fireTiles[i];
                        f.life -= dt;
                        if (f.life <= 0) {
                            this.fireTiles.splice(i, 1);
                        } else {
                            // Ghost Damage
                            this.ghosts.forEach(g => {
                                let gr = Math.round(g.y / TILE_SIZE);
                                let gc = Math.round(g.x / TILE_SIZE);
                                if (gr === f.r && gc === f.c && g.mode !== 'EATEN' && g.mode !== 'FRIGHTENED') {
                                    // Burn ghost
                                    this.audio.playEatGhost();
                                    g.mode = 'EATEN';
                                    this.addScore(200);
                                }
                            });
                        }
                    }
                }

                // Update Projectiles (Bullet)
                // Shoot Trigger
                if (this.perks.includes('bullet') && this.state === 'PLAYING') {
                    this.bulletTimer += dt;
                    if (this.bulletTimer > 2000) { // 2 Seconds
                        this.bulletTimer = 0;
                        this.shootBullet();
                    }
                }

                // Move Projectiles
                if (this.projectiles.length > 0) {
                    for (let i = this.projectiles.length - 1; i >= 0; i--) {
                        let p = this.projectiles[i];
                        p.x += p.dx * 8; // Fast speed
                        p.y += p.dy * 8;

                        // Wall Collision
                        let r = Math.floor(p.y / TILE_SIZE);
                        let c = Math.floor(p.x / TILE_SIZE);
                        if (this.map.isWall(r, c)) {
                            this.projectiles.splice(i, 1);
                            continue;
                        }

                        // Ghost Collision
                        let hit = false;
                        for (let g of this.ghosts) {
                            if (g.mode === 'EATEN') continue;
                            let dist = Math.hypot(g.x - p.x, g.y - p.y);
                            if (dist < TILE_SIZE) {
                                g.mode = 'EATEN';
                                this.addScore(200);
                                this.audio.playEatGhost();
                                this.projectiles.splice(i, 1);
                                hit = true;
                                break;
                            }
                        }
                    }
                }
            }

            updateLevelUp(dt) {
                const mouse = this.input.getMouseStatus();
                if (!mouse.clicked) return;

                const cardWidth = 120;
                const cardHeight = 160;
                const gap = 20;
                const totalWidth = 3 * cardWidth + 2 * gap;
                const startX = (CANVAS_WIDTH - totalWidth) / 2;
                const startY = 150;

                this.offeredPerks.forEach((perk, index) => {
                    const x = startX + index * (cardWidth + gap);
                    const y = startY;

                    if (mouse.x >= x && mouse.x <= x + cardWidth && mouse.y >= y && mouse.y <= y + cardHeight) {
                        this.selectPerk(perk.id);
                    }
                });
            }

            // NOTE: We need to trigger chomp sound.
            // In Pacman.update, we can assume if it moved, we chomp.
            // But doing it here is messy.
            // I will update Pacman class via a separate tool call if needed or just patch it.
            // Actually, I can rely on a simple interval for "wakka wakka" if moving.

            shootBullet() {
                // Find nearest ghost
                let nearest = null;
                let minDst = Infinity;

                this.ghosts.forEach(g => {
                    if (g.mode === 'EATEN') return;
                    let dst = Math.hypot(g.x - this.pacman.x, g.y - this.pacman.y);
                    if (dst < minDst) {
                        minDst = dst;
                        nearest = g;
                    }
                });

                if (nearest) {
                    let dx = nearest.x - this.pacman.x;
                    let dy = nearest.y - this.pacman.y;
                    let len = Math.hypot(dx, dy);
                    if (len > 0) {
                        dx /= len;
                        dy /= len;
                        this.projectiles.push({ x: this.pacman.x + TILE_SIZE / 2, y: this.pacman.y + TILE_SIZE / 2, dx, dy });
                    }
                }
            }

            draw() {
                ctx.fillStyle = COLOR_BG;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                this.map.draw(ctx);

                // Draw Fire
                ctx.fillStyle = 'rgba(255, 69, 0, 0.6)'; // OrangeRed transparent
                this.fireTiles.forEach(f => {
                    ctx.fillRect(f.c * TILE_SIZE, f.r * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    // Flicker center
                    if (Math.random() > 0.5) {
                        ctx.fillStyle = 'rgba(255, 215, 0, 0.8)';
                        ctx.fillRect(f.c * TILE_SIZE + 4, f.r * TILE_SIZE + 4, TILE_SIZE - 8, TILE_SIZE - 8);
                        ctx.fillStyle = 'rgba(255, 69, 0, 0.6)'; // Reset
                    }
                });

                // Draw Projectiles
                ctx.fillStyle = '#FFF';
                this.projectiles.forEach(p => {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                    ctx.fill();
                });

                this.pacman.draw(ctx);
                this.ghosts.forEach(g => g.draw(ctx));

                // UI Overlay
                if (this.state === 'READY') {
                    ctx.fillStyle = 'yellow';
                    ctx.font = '20px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillText("PRESS SPACE TO START", canvas.width / 2, canvas.height / 2 + 20);
                } else if (this.state === 'GAMEOVER') {
                    ctx.fillStyle = 'red';
                    ctx.font = '30px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2);
                    ctx.fillText("Press Space to Restart", canvas.width / 2, canvas.height / 2 + 30);
                } else if (this.state === 'LEVEL_UP') {
                    this.drawLevelUpMenu(ctx);
                }

                this.drawXpBar(ctx);
            }

            drawXpBar(ctx) {
                const barHeight = 10;
                const barWidth = CANVAS_WIDTH;
                const fillPercent = Math.min(1, this.xp / this.xpMax);

                // Background
                ctx.fillStyle = '#333';
                ctx.fillRect(0, CANVAS_HEIGHT - barHeight, barWidth, barHeight);

                // Fill
                ctx.fillStyle = '#00FF00'; // Green XP
                ctx.fillRect(0, CANVAS_HEIGHT - barHeight, barWidth * fillPercent, barHeight);

                // Text
                ctx.fillStyle = 'white';
                ctx.font = '10px monospace';
                ctx.textAlign = 'left';
                ctx.fillText(`LVL ${this.level}`, 5, CANVAS_HEIGHT - 12);
            }

            drawLevelUpMenu(ctx) {
                // Overlay
                ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.font = '30px monospace';
                ctx.fillText('LEVEL UP!', CANVAS_WIDTH / 2, 80);

                ctx.font = '16px monospace';
                ctx.fillText('Choose a Perk:', CANVAS_WIDTH / 2, 110);

                // Draw Cards
                const cardWidth = 120;
                const cardHeight = 160;
                const gap = 20;
                const totalWidth = 3 * cardWidth + 2 * gap;
                const startX = (CANVAS_WIDTH - totalWidth) / 2;
                const startY = 150;

                this.offeredPerks.forEach((perk, index) => {
                    const x = startX + index * (cardWidth + gap);
                    const y = startY;

                    // Highlight
                    const mouse = this.input.getMouseStatus();
                    const mx = this.input.mouseX; // Peek
                    const my = this.input.mouseY;
                    const hovered = mx >= x && mx <= x + cardWidth && my >= y && my <= y + cardHeight;

                    // Card Bg
                    ctx.fillStyle = hovered ? '#444' : '#222';
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.fillRect(x, y, cardWidth, cardHeight);
                    ctx.strokeRect(x, y, cardWidth, cardHeight);

                    // Title
                    ctx.fillStyle = '#FFFF00';
                    ctx.font = '14px monospace';
                    ctx.fillText(perk.name, x + cardWidth / 2, y + 30);

                    // Desc
                    ctx.fillStyle = '#DDD';
                    ctx.font = '12px monospace';
                    this.wrapText(ctx, perk.desc, x + cardWidth / 2, y + 60, cardWidth - 10, 16);
                });
            }

            wrapText(ctx, text, x, y, maxWidth, lineHeight) {
                const words = text.split(' ');
                let line = '';
                for (let n = 0; n < words.length; n++) {
                    const testLine = line + words[n] + ' ';
                    const metrics = ctx.measureText(testLine);
                    const testWidth = metrics.width;
                    if (testWidth > maxWidth && n > 0) {
                        ctx.fillText(line, x, y);
                        line = words[n] + ' ';
                        y += lineHeight;
                    }
                    else {
                        line = testLine;
                    }
                }
                ctx.fillText(line, x, y);
            }


            // Loop removed, driven by GameManager
            // loop(timestamp) { ... }

            softReset() {
                // Difficulty Scaling
                // Base speed 1. Increase by 10% per level. Cap at 2.0 (Pacman speed).
                const diffMultiplier = 1 + (this.level - 1) * 0.1;
                const newSpeed = Math.min(2.0, 1 * diffMultiplier);

                // Reset Ghosts positions & modes
                this.ghosts = [
                    new Ghost(13.5, 11, 'red', 0, this.map),
                    new Ghost(13.5, 14, 'pink', 1, this.map),
                    new Ghost(11.5, 14, 'cyan', 2, this.map),
                    new Ghost(15.5, 14, 'orange', 3, this.map)
                ];

                // Apply speed
                this.ghosts.forEach(g => g.speed = newSpeed);

                this.ghosts[0].mode = 'SCATTER';
                this.ghosts[0].dir = [LEFT, RIGHT][Math.floor(Math.random() * 2)]; // Force Blinky Horizontal

                this.pacman = new Pacman(13.5, 22, this.map, this);

                this.ghostsReleased = 1;
                this.ghostReleaseTimer = 0;
                this.modeTimer = 0;
                this.globalMode = 'SCATTER';
                this.powerMode = false;
                clearTimeout(this.powerTimer);

                // Keep Projectiles? Probably clear them on level reset to be fair.
                this.projectiles = [];
                // Keep Fire? Maybe clear fire tiles too.
                this.fireTiles = [];
            }
        }

        // --- GALAGA CLASSES ---

        class GalagaStar {
            constructor() {
                this.init();
            }
            init() {
                this.x = Math.random() * CANVAS_WIDTH;
                this.y = Math.random() * CANVAS_HEIGHT;
                this.speed = 0.5 + Math.random() * 2;
                this.size = Math.random() < 0.1 ? 2 : 1;
                if (Math.random() < 0.05) this.color = ['#F00', '#0F0', '#00F', '#FF0'][Math.floor(Math.random() * 4)];
                else this.color = '#FFF';
            }
            update() {
                this.y += this.speed;
                if (this.y > CANVAS_HEIGHT) this.init(); // Reset to top random
                if (this.y < 0) this.y = 0; // Just in case init puts at bottom
                if (this.y < 5 && Math.random() > 0.5) this.y = 0; // Reset logic fix: loop top
            }
            draw(ctx) {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.size, this.size);
            }
        }

        class GalagaPlayer {
            constructor(input) {
                this.x = CANVAS_WIDTH / 2;
                this.y = CANVAS_HEIGHT - 40;
                this.width = 16;
                this.height = 16;
                this.speed = 3;
                this.input = input;
                this.cooldown = 0;
            }

            update(dt, game) {
                // Use isKeyDown for smooth movement
                if (game.input.isKeyDown('ArrowLeft')) this.x -= this.speed;
                if (game.input.isKeyDown('ArrowRight')) this.x += this.speed;

                if (this.x < 10) this.x = 10;
                if (this.x > CANVAS_WIDTH - 10) this.x = CANVAS_WIDTH - 10;

                // Shooting
                // Space or Up or Click
                if (game.input.mouseClicked || game.input.isKeyDown('ArrowUp') || game.input.isKeyDown('Space')) {
                    if (this.cooldown <= 0) {
                        game.projectiles.push(new GalagaBullet(this.x, this.y - 10, -1, true)); // Up
                        this.cooldown = 300; // ms
                        game.audio.playTone(400, 'square', 0.1);
                    }
                }
                if (this.cooldown > 0) this.cooldown -= dt;
            }

            draw(ctx) {
                ctx.fillStyle = '#FFF';
                // Ship shape
                ctx.beginPath();
                ctx.moveTo(this.x, this.y - 8);
                ctx.lineTo(this.x + 8, this.y + 8);
                ctx.lineTo(this.x, this.y + 4);
                ctx.lineTo(this.x - 8, this.y + 8);
                ctx.fill();

                ctx.fillStyle = '#F00';
                ctx.fillRect(this.x - 2, this.y - 6, 4, 4);
            }
        }

        class GalagaBullet {
            constructor(x, y, dy, isPlayer) {
                this.x = x;
                this.y = y;
                this.dy = dy; // Direction Y (1 or -1)
                this.speed = 6;
                this.isPlayer = isPlayer;
                this.remove = false;
            }
            update() {
                this.y += this.dy * this.speed;
                if (this.y < 0 || this.y > CANVAS_HEIGHT) this.remove = true;
            }
            draw(ctx) {
                ctx.fillStyle = this.isPlayer ? '#FF0' : '#F0F';
                ctx.fillRect(this.x - 1, this.y - 4, 2, 8);
            }
        }

        class GalagaEnemy {
            constructor(x, y, type) {
                this.x = x; // Grid target X
                this.y = y; // Grid target Y
                this.realX = Math.random() * CANVAS_WIDTH; // Spawn pos
                this.realY = -20;
                this.type = type; // 0: Bee, 1: Butterfly, 2: Boss
                this.state = 'ENTERING'; // ENTERING, GRID, DIVE
                this.t = 0;
                this.divePath = null;
            }
            update(dt, game) {
                const time = Date.now();
                // Formatting
                if (this.state === 'ENTERING') {
                    let dx = this.x - this.realX;
                    let dy = this.y - this.realY;
                    this.realX += dx * 0.05;
                    this.realY += dy * 0.05;
                    if (Math.abs(dx) < 1 && Math.abs(dy) < 1) this.state = 'GRID';
                } else if (this.state === 'GRID') {
                    // Hover movement
                    this.realX = this.x + Math.sin(time * 0.002 + this.y * 0.1) * 5;
                    this.realY = this.y + Math.cos(time * 0.003) * 2;

                    // Random Dive
                    if (Math.random() < 0.001) { // 0.1% chance per frame
                        this.state = 'DIVE';
                        this.divePath = {
                            t: 0,
                            startX: this.realX,
                            startY: this.realY,
                            controlX: this.realX + (Math.random() - 0.5) * 200,
                            controlY: this.realY + 100,
                            endX: game.player.x,
                            endY: CANVAS_HEIGHT + 50
                        };
                        game.audio.playTone(300 + Math.random() * 200, 'sawtooth', 0.2);
                    }
                } else if (this.state === 'DIVE') {
                    this.divePath.t += dt * 0.002;
                    if (this.divePath.t > 1) {
                        this.state = 'RETURN'; // Or just reset to top
                        this.realY = -20;
                        this.state = 'ENTERING';
                        return;
                    }

                    // Bezier
                    const t = this.divePath.t;
                    const u = 1 - t;
                    const p0 = { x: this.divePath.startX, y: this.divePath.startY };
                    const p1 = { x: this.divePath.controlX, y: this.divePath.controlY };
                    const p2 = { x: this.divePath.endX, y: this.divePath.endY };

                    this.realX = u * u * p0.x + 2 * u * t * p1.x + t * t * p2.x;
                    this.realY = u * u * p0.y + 2 * u * t * p1.y + t * t * p2.y;

                    // Shoot?
                    if (game.player && Math.random() < 0.02) {
                        // Aim at player
                        // Simple down for now or vector
                        game.projectiles.push(new GalagaBullet(this.realX, this.realY, 1, false));
                    }

                    // Collision with player checked in Game
                    if (game.player && Math.hypot(this.realX - game.player.x, this.realY - game.player.y) < 16) {
                        game.lives--;
                        game.audio.playDie();
                        this.state = 'ENTERING'; // Respawn enemy
                        // Actually enemy should die too?
                        // In Galaga Kamikaze kills both.
                        // But let's just punish player.
                        if (game.lives <= 0) game.state = 'GAMEOVER';
                    }
                }
            }
            draw(ctx) {
                let color = '#FF0'; // Bee
                if (this.type === 1) color = '#F00'; // Butterfly
                if (this.type === 2) color = '#0F0'; // Boss

                ctx.fillStyle = color;

                const x = this.realX;
                const y = this.realY;

                // Draw Alien logic
                ctx.beginPath();
                if (this.type === 0) { // BEE
                    ctx.moveTo(x, y - 5); ctx.lineTo(x + 6, y - 2); ctx.lineTo(x + 4, y + 4); ctx.lineTo(x - 4, y + 4); ctx.lineTo(x - 6, y - 2);
                } else if (this.type === 1) { // BUTTERFLY
                    ctx.moveTo(x, y + 4); ctx.lineTo(x + 6, y - 4); ctx.lineTo(x, y); ctx.lineTo(x - 6, y - 4);
                } else { // BOSS
                    ctx.moveTo(x, y + 6); ctx.lineTo(x + 8, y - 4); ctx.lineTo(x, y - 6); ctx.lineTo(x - 8, y - 4);
                }
                ctx.fill();

                // Eyes
                ctx.fillStyle = 'black';
                ctx.fillRect(x - 2, y - 2, 1, 1);
                ctx.fillRect(x + 1, y - 2, 1, 1);
            }
        }

        class GalagaGame {
            constructor(input, audio) {
                this.input = input;
                this.audio = audio;
                this.player = new GalagaPlayer(input);
                this.stars = [];
                for (let i = 0; i < 50; i++) this.stars.push(new GalagaStar());

                this.enemies = [];
                this.projectiles = [];
                this.score = 0;
                this.lives = 3;
                this.wave = 1;
                this.state = 'PLAYING';

                this.spawnWave();
            }

            init() {
                // Nothing needed really
            }

            spawnWave() {
                // Create grid
                const rows = 4;
                const cols = 10;
                const startX = 60;
                const startY = 50;
                const gap = 30;

                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        let type = 0;
                        if (r === 0) type = 2; // Boss
                        else if (r === 1) type = 1; // Butterfly
                        this.enemies.push(new GalagaEnemy(startX + c * gap, startY + r * gap, type));
                    }
                }
            }

            update(dt) {
                const time = Date.now();

                // Update stars
                this.stars.forEach(s => s.update());

                if (this.lives <= 0) {
                    this.state = 'GAMEOVER';
                    return;
                }

                this.player.update(dt, this);

                // Enemies
                this.enemies.forEach(e => e.update(dt, this));

                // Next Wave
                if (this.enemies.length === 0) {
                    this.wave++;
                    this.spawnWave();
                    // Audio Level Start
                    this.audio.playTone(600, 'square', 0.5);
                }

                // Projectiles
                for (let i = this.projectiles.length - 1; i >= 0; i--) {
                    let p = this.projectiles[i];
                    p.update();
                    if (p.remove) {
                        this.projectiles.splice(i, 1);
                        continue;
                    }

                    // Collision
                    if (p.isPlayer) {
                        // Check vs Enemies
                        for (let j = this.enemies.length - 1; j >= 0; j--) {
                            let e = this.enemies[j];
                            if (Math.hypot(p.x - e.realX, p.y - e.realY) < 12) {
                                // Hit
                                this.enemies.splice(j, 1);
                                this.projectiles.splice(i, 1);
                                this.score += 100 * (1 + e.type); // More points for bosses
                                this.audio.playTone(800, 'sawtooth', 0.05);
                                p.remove = true; // Optimization
                                break;
                            }
                        }
                    } else {
                        // Enemy Bullet vs Player
                        if (Math.hypot(p.x - this.player.x, p.y - this.player.y) < 10) {
                            this.lives--;
                            this.projectiles.splice(i, 1);
                            this.audio.playDie();
                            if (this.lives <= 0) this.state = 'GAMEOVER';
                            break;
                        }
                    }
                }
            }

            draw(ctx) {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                this.stars.forEach(s => s.draw(ctx));

                this.player.draw(ctx);
                this.enemies.forEach(e => e.draw(ctx));
                this.projectiles.forEach(p => p.draw(ctx));

                // UI
                ctx.fillStyle = 'red';
                ctx.font = '20px Courier New';
                ctx.textAlign = 'left';
                ctx.fillText(`SCORE: ${this.score}`, 10, 20);

                if (this.state === 'GAMEOVER') {
                    ctx.fillStyle = 'red';
                    ctx.font = '30px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillText("GAME OVER", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
                    ctx.font = '15px Courier New';
                    ctx.fillText("Press Esc to Menu", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 30);
                }
            }
        }

        // --- Initialization ---
        // const game = new Game();
        // game.init();

        // --- ASTEROIDS CLASSES ---

        class AsteroidsBullet {
            constructor(x, y, angle, isEnemy = false) {
                this.x = x;
                this.y = y;
                this.speed = 5;
                this.vx = Math.cos(angle) * this.speed;
                this.vy = Math.sin(angle) * this.speed;
                this.life = 60; // Frames (approx 1 sec)
                this.isEnemy = isEnemy;
                this.remove = false;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life--;

                // Wrap
                if (this.x < 0) this.x += CANVAS_WIDTH;
                if (this.x > CANVAS_WIDTH) this.x -= CANVAS_WIDTH;
                if (this.y < 0) this.y += CANVAS_HEIGHT;
                if (this.y > CANVAS_HEIGHT) this.y -= CANVAS_HEIGHT;

                if (this.life <= 0) this.remove = true;
            }

            draw(ctx) {
                ctx.fillStyle = '#FFF';
                ctx.fillRect(this.x - 1, this.y - 1, 2, 2);
            }
        }

        class Asteroid {
            constructor(x, y, size) {
                this.x = x;
                this.y = y;
                this.size = size; // 3: Large, 2: Medium, 1: Small
                this.radius = size === 3 ? 20 : (size === 2 ? 10 : 5);

                // Random Velocity
                const speed = (4 - size) * 0.5; // Smaller = faster
                const angle = Math.random() * Math.PI * 2;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;

                // Polygon shape
                this.points = [];
                const vertices = 8 + Math.floor(Math.random() * 4);
                for (let i = 0; i < vertices; i++) {
                    const a = (i / vertices) * Math.PI * 2;
                    const r = this.radius * (0.8 + Math.random() * 0.4);
                    this.points.push({ x: Math.cos(a) * r, y: Math.sin(a) * r });
                }
                this.remove = false;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;

                // Wrap
                if (this.x < -this.radius) this.x += CANVAS_WIDTH + this.radius * 2;
                if (this.x > CANVAS_WIDTH + this.radius) this.x -= CANVAS_WIDTH + this.radius * 2;
                if (this.y < -this.radius) this.y += CANVAS_HEIGHT + this.radius * 2;
                if (this.y > CANVAS_HEIGHT + this.radius) this.y -= CANVAS_HEIGHT + this.radius * 2;
            }

            draw(ctx) {
                ctx.strokeStyle = '#FFF';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(this.x + this.points[0].x, this.y + this.points[0].y);
                for (let i = 1; i < this.points.length; i++) {
                    ctx.lineTo(this.x + this.points[i].x, this.y + this.points[i].y);
                }
                ctx.closePath();
                ctx.stroke();
            }
        }

        class SpaceShip {
            constructor() {
                this.x = CANVAS_WIDTH / 2;
                this.y = CANVAS_HEIGHT / 2;
                this.vx = 0;
                this.vy = 0;
                this.angle = -Math.PI / 2; // Up
                this.rotation = 0;
                this.thrusting = false;
                this.cooldown = 0;
                this.visible = true;
                this.radius = 6;
                this.hyperspaceWait = 0;
            }

            update(input, game) {
                if (!this.visible) return;

                // Rotation
                if (input.isKeyDown('ArrowLeft')) this.rotation = -0.1;
                else if (input.isKeyDown('ArrowRight')) this.rotation = 0.1;
                else this.rotation = 0;

                this.angle += this.rotation;

                // Thrust
                this.thrusting = input.isKeyDown('ArrowUp');
                if (this.thrusting) {
                    this.vx += Math.cos(this.angle) * 0.05; // Acceleration
                    this.vy += Math.sin(this.angle) * 0.05;
                }

                // Friction
                this.vx *= 0.99;
                this.vy *= 0.99;

                // Position
                this.x += this.vx;
                this.y += this.vy;

                // Wrap
                if (this.x < 0) this.x += CANVAS_WIDTH;
                if (this.x > CANVAS_WIDTH) this.x -= CANVAS_WIDTH;
                if (this.y < 0) this.y += CANVAS_HEIGHT;
                if (this.y > CANVAS_HEIGHT) this.y -= CANVAS_HEIGHT;

                // Shooting
                if (input.isKeyDown('Space') && this.cooldown <= 0) {
                    game.bullets.push(new AsteroidsBullet(this.x + Math.cos(this.angle) * 8, this.y + Math.sin(this.angle) * 8, this.angle));
                    this.cooldown = 15;
                    game.audio.playTone(800, 'triangle', 0.05);
                }
                if (this.cooldown > 0) this.cooldown--;

                // Hyperspace
                if (input.isKeyDown('ShiftLeft') || input.isKeyDown('ShiftRight')) {
                    if (this.hyperspaceWait <= 0) {
                        this.x = Math.random() * CANVAS_WIDTH;
                        this.y = Math.random() * CANVAS_HEIGHT;
                        this.vx = 0;
                        this.vy = 0;
                        this.hyperspaceWait = 30; // 0.5 sec debounce
                    }
                }
                if (this.hyperspaceWait > 0) this.hyperspaceWait--;
            }

            draw(ctx) {
                if (!this.visible) return;

                ctx.strokeStyle = '#FFF';
                ctx.lineWidth = 1;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                // Ship
                ctx.beginPath();
                ctx.moveTo(10, 0); // Nose
                ctx.lineTo(-7, 5);
                ctx.lineTo(-7, -5);
                ctx.closePath();
                ctx.stroke();

                // Thrust flame
                if (this.thrusting) {
                    ctx.beginPath();
                    ctx.moveTo(-7, 0);
                    ctx.lineTo(-12, 0);
                    ctx.stroke();
                }

                ctx.restore();
            }
        }

        class Ufo {
            constructor(type, player) {
                this.type = type; // 1: Small, 2: Large
                this.y = Math.random() * CANVAS_HEIGHT;
                this.x = (Math.random() < 0.5) ? 0 : CANVAS_WIDTH;
                this.vx = (this.x === 0 ? 1 : -1) * (type === 1 ? 1.5 : 1); // Small is faster
                // Random Y drift
                this.vy = (Math.random() - 0.5) * 0.5;

                this.timer = 0;
                this.shootTimer = 0;
                this.player = player;
                this.remove = false;
                this.radius = 10;
            }

            update(game) {
                this.x += this.vx;
                this.y += this.vy;

                // Change direction occasionally
                this.timer++;
                if (this.timer > 200 && Math.random() < 0.02) {
                    this.vy = (Math.random() - 0.5) * 2;
                    this.timer = 0;
                }

                // Wrap Y
                if (this.y < 0) this.y += CANVAS_HEIGHT;
                if (this.y > CANVAS_HEIGHT) this.y -= CANVAS_HEIGHT;

                // Remove checks
                if ((this.vx > 0 && this.x > CANVAS_WIDTH) || (this.vx < 0 && this.x < 0)) {
                    this.remove = true;
                }

                // Shoot
                this.shootTimer++;
                if (this.shootTimer > 120) { // Shoot every 2 sec approx
                    this.shootTimer = 0;
                    let angle = Math.random() * Math.PI * 2;
                    if (this.type === 1 && this.player && this.player.visible) {
                        // Aim at player
                        angle = Math.atan2(this.player.y - this.y, this.player.x - this.x);
                        // Small inaccuracy
                        angle += (Math.random() - 0.5) * 0.2;
                    }
                    game.bullets.push(new AsteroidsBullet(this.x, this.y, angle, true));
                    game.audio.playTone(600, 'sawtooth', 0.1);
                }
            }

            draw(ctx) {
                ctx.strokeStyle = '#FFF';
                ctx.lineWidth = 1;
                ctx.beginPath();
                // Saucer shape
                ctx.moveTo(this.x - 10, this.y + 2);
                ctx.lineTo(this.x + 10, this.y + 2); // Bottom
                ctx.lineTo(this.x + 5, this.y - 3); // Mid R
                ctx.lineTo(this.x - 5, this.y - 3); // Mid L
                ctx.lineTo(this.x - 10, this.y + 2);
                // Dome
                ctx.moveTo(this.x - 3, this.y - 3);
                ctx.lineTo(this.x - 2, this.y - 6);
                ctx.lineTo(this.x + 2, this.y - 6);
                ctx.lineTo(this.x + 3, this.y - 3);
                ctx.stroke();
            }
        }

        class AsteroidsGame {
            constructor(input, audio) {
                this.input = input;
                this.audio = audio;
                this.ship = new SpaceShip();
                this.asteroids = [];
                this.bullets = [];
                this.ufo = null;
                this.score = 0;
                this.lives = 3;
                this.level = 0;
                this.state = 'PLAYING';

                this.ufoTimer = 0;
                this.respawnTimer = 0;

                this.nextLevel();
            }

            init() { }

            nextLevel() {
                this.level++;
                this.asteroids = [];
                const count = 2 + this.level * 2; // Increase asteroids
                for (let i = 0; i < count; i++) {
                    let x, y;
                    // Dont spawn on ship
                    do {
                        x = Math.random() * CANVAS_WIDTH;
                        y = Math.random() * CANVAS_HEIGHT;
                    } while (Math.hypot(x - this.ship.x, y - this.ship.y) < 100);

                    this.asteroids.push(new Asteroid(x, y, 3));
                }
            }

            update(dt) {
                if (this.state === 'GAMEOVER') {
                    if (this.input.isKeyDown('Space')) {
                        // Reset handled by GameManager usually or request restart?
                    }
                    return;
                }

                // Respawn Ship
                if (!this.ship.visible && this.lives > 0) {
                    this.respawnTimer -= dt;
                    if (this.respawnTimer <= 0) {
                        // Check if safe
                        let safe = true;
                        for (let a of this.asteroids) {
                            if (Math.hypot(a.x - CANVAS_WIDTH / 2, a.y - CANVAS_HEIGHT / 2) < 50) safe = false;
                        }
                        if (this.ufo) {
                            if (Math.hypot(this.ufo.x - CANVAS_WIDTH / 2, this.ufo.y - CANVAS_HEIGHT / 2) < 50) safe = false;
                        }

                        if (safe) {
                            this.ship.x = CANVAS_WIDTH / 2;
                            this.ship.y = CANVAS_HEIGHT / 2;
                            this.ship.vx = 0;
                            this.ship.vy = 0;
                            this.ship.visible = true;
                            // Brief invulnerability? Or just hope safe check was good.
                        } else {
                            this.respawnTimer = 200; // Wait more
                        }
                    }
                }

                this.ship.update(this.input, this);
                this.asteroids.forEach(a => a.update());
                this.bullets.forEach(b => b.update());
                if (this.ufo) this.ufo.update(this);

                // Clean bullets
                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    if (this.bullets[i].remove) this.bullets.splice(i, 1);
                }

                // Level Clear
                if (this.asteroids.length === 0 && !this.ufo) {
                    // Small delay?
                    setTimeout(() => { if (this.asteroids.length === 0) this.nextLevel() }, 1000);
                }

                // Ufo Spawning
                if (!this.ufo && this.asteroids.length > 0) {
                    this.ufoTimer += dt;
                    if (this.ufoTimer > 10000 + Math.random() * 10000) { // 10-20s
                        this.ufo = new Ufo(Math.random() < 0.3 ? 1 : 2, this.ship); // 30% Chance of small
                        this.ufoTimer = 0;
                    }
                }
                if (this.ufo && this.ufo.remove) this.ufo = null;


                // Collisions
                this.checkCollisions();
            }

            checkCollisions() {
                // Bullets hit Asteroids/UFO
                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    let b = this.bullets[i];
                    if (b.remove) continue;

                    if (!b.isEnemy) {
                        // Hit Asteroid
                        for (let j = this.asteroids.length - 1; j >= 0; j--) {
                            let a = this.asteroids[j];
                            if (Math.hypot(a.x - b.x, a.y - b.y) < a.radius) {
                                // Hit!
                                this.score += (a.size === 3 ? 20 : (a.size === 2 ? 50 : 100));
                                this.audio.playTone(100 + a.size * 50, 'noise', 0.1);
                                b.remove = true;

                                // Split
                                this.asteroids.splice(j, 1);
                                if (a.size > 1) {
                                    this.asteroids.push(new Asteroid(a.x, a.y, a.size - 1));
                                    this.asteroids.push(new Asteroid(a.x, a.y, a.size - 1));
                                }
                                break;
                            }
                        }

                        // Hit UFO
                        if (this.ufo && !b.remove) {
                            if (Math.hypot(this.ufo.x - b.x, this.ufo.y - b.y) < this.ufo.radius) {
                                this.score += (this.ufo.type === 1 ? 1000 : 200);
                                this.audio.playTone(800, 'noise', 0.2);
                                this.ufo = null;
                                b.remove = true;
                            }
                        }
                    } else {
                        // Enemy Bullet hit Player
                        if (this.ship.visible && Math.hypot(this.ship.x - b.x, this.ship.y - b.y) < this.ship.radius) {
                            this.killShip();
                            b.remove = true;
                        }
                    }
                }

                // Player vs Asteroid/UFO
                if (this.ship.visible) {
                    for (let a of this.asteroids) {
                        if (Math.hypot(a.x - this.ship.x, a.y - this.ship.y) < a.radius + this.ship.radius) {
                            this.killShip();
                            break;
                        }
                    }
                    if (this.ufo) {
                        if (Math.hypot(this.ufo.x - this.ship.x, this.ufo.y - this.ship.y) < this.ufo.radius + this.ship.radius) {
                            this.killShip();
                        }
                    }
                }
            }

            killShip() {
                this.lives--;
                this.ship.visible = false;
                this.audio.playDie();
                this.respawnTimer = 2000;
                if (this.lives <= 0) this.state = 'GAMEOVER';
                this.ship.vx = 0; this.ship.vy = 0;
            }

            draw(ctx) {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                this.ship.draw(ctx);
                this.asteroids.forEach(a => a.draw(ctx));
                this.bullets.forEach(b => b.draw(ctx));
                if (this.ufo) this.ufo.draw(ctx);

                // UI
                ctx.fillStyle = '#FFF';
                ctx.font = '20px Courier New';
                ctx.textAlign = 'left';
                ctx.fillText(`SCORE: ${this.score}`, 10, 20);

                // Draw lives
                for (let i = 0; i < this.lives; i++) {
                    ctx.strokeStyle = '#FFF';
                    ctx.beginPath();
                    let lx = 10 + i * 15;
                    let ly = 40;
                    ctx.moveTo(lx, ly - 5);
                    ctx.lineTo(lx - 4, ly + 5);
                    ctx.lineTo(lx + 4, ly + 5);
                    ctx.closePath();
                    ctx.stroke();
                }

                if (this.state === 'GAMEOVER') {
                    ctx.fillStyle = 'red';
                    ctx.font = '30px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillText("GAME OVER", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
                    ctx.font = '15px Courier New';
                    ctx.fillText("Press Esc to Menu", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 30);
                }
            }
        }

        // --- Game Manager & Entry Point ---
        class GameManager {
            constructor() {
                this.input = new InputHandler();
                this.audio = new AudioController();

                this.state = 'MENU'; // MENU, PACMAN, GALAGA, ASTEROIDS
                this.currentGame = null;

                this.menuSelection = 0; // 0: Pacman, 1: Galaga, 2: Asteroids
                this.optionCount = 3;

                // Initialize loop
                this.lastTime = 0;
                requestAnimationFrame((t) => this.loop(t));

                // Menu controls
                window.addEventListener('keydown', (e) => {
                    if (this.state === 'MENU') {
                        if (e.key === 'ArrowUp' || e.key === 'ArrowLeft') {
                            this.menuSelection = (this.menuSelection - 1 + this.optionCount) % this.optionCount;
                            this.audio.playTone(200, 'square', 0.05);
                        }
                        if (e.key === 'ArrowDown' || e.key === 'ArrowRight') {
                            this.menuSelection = (this.menuSelection + 1) % this.optionCount;
                            this.audio.playTone(200, 'square', 0.05);
                        }
                        if (e.key === 'Enter' || e.key === ' ') {
                            this.startGame();
                        }
                    } else if (this.currentGame) {
                        // Allow resetting to menu? For now, no keybind, just rely on game over or reload
                        // Maybe Esc to Menu?
                        if (e.key === 'Escape') {
                            this.state = 'MENU';
                            this.currentGame = null;
                        }
                    }
                });
            }

            startGame() {
                this.audio.ctx && this.audio.ctx.resume();
                if (this.menuSelection === 0) {
                    this.state = 'PACMAN';
                    this.currentGame = new PacmanGame(this.input, this.audio);
                    this.currentGame.init();
                } else if (this.menuSelection === 1) {
                    this.state = 'GALAGA';
                    this.currentGame = new GalagaGame(this.input, this.audio);
                } else if (this.menuSelection === 2) {
                    this.state = 'ASTEROIDS';
                    this.currentGame = new AsteroidsGame(this.input, this.audio);
                }
            }

            loop(timestamp) {
                const dt = timestamp - this.lastTime;
                this.lastTime = timestamp;

                if (this.state === 'MENU') {
                    this.drawMenu();
                } else if (this.currentGame) {
                    if (this.state === 'PACMAN') {
                        this.currentGame.update(dt);
                        this.currentGame.draw(ctx);
                    } else if (this.state === 'GALAGA') {
                        this.currentGame.update(dt);
                        this.currentGame.draw(ctx);
                    } else if (this.state === 'ASTEROIDS') {
                        this.currentGame.update(dt);
                        this.currentGame.draw(ctx);
                    }
                }

                requestAnimationFrame((t) => this.loop(t));
            }

            drawMenu() {
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                ctx.fillStyle = '#FFFF00';
                ctx.font = '40px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText("ARCADE", CANVAS_WIDTH / 2, 100);

                ctx.font = '24px Courier New';

                // Option 1: PAC-MAN
                ctx.fillStyle = (this.menuSelection === 0) ? '#FFFF00' : '#555';
                ctx.fillText((this.menuSelection === 0 ? "> " : "") + "PAC-MAN", CANVAS_WIDTH / 2, 200);

                // Option 2: GALAGA
                ctx.fillStyle = (this.menuSelection === 1) ? '#FF0000' : '#555';
                ctx.fillText((this.menuSelection === 1 ? "> " : "") + "GALAGA", CANVAS_WIDTH / 2, 250);

                // Option 3: ASTEROIDS
                ctx.fillStyle = (this.menuSelection === 2) ? '#FFFFFF' : '#555';
                ctx.fillText((this.menuSelection === 2 ? "> " : "") + "ASTEROIDS", CANVAS_WIDTH / 2, 300);

                ctx.fillStyle = '#888';
                ctx.font = '14px Courier New';
                ctx.fillText("Use Arrow Keys & Enter", CANVAS_WIDTH / 2, 400);
            }
        }

        const gameManager = new GameManager();



    </script>
</body>

</html>