<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Pac-Man Clone</title>
    <style>
        body {
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
            color: white;
        }

        canvas {
            border: 2px solid #555;
            box-shadow: 0 0 20px rgba(0, 0, 255, 0.2);
        }

        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 20px;
        }
    </style>
</head>

<body>
    <div id="ui">Score: <span id="score">0</span> &nbsp; Lives: <span id="lives">10</span></div>
    <canvas id="gameCanvas"></canvas>

    <script>
        // --- Constants ---
        const TILE_SIZE = 16;
        const GRID_WIDTH = 28;
        const GRID_HEIGHT = 31;
        const CANVAS_WIDTH = GRID_WIDTH * TILE_SIZE;   // 448
        const CANVAS_HEIGHT = GRID_HEIGHT * TILE_SIZE; // 496

        // Directions
        const NONE = 0;
        const UP = 1;
        const DOWN = 2;
        const LEFT = 3;
        const RIGHT = 4;

        // Tile Types
        const WALL = 0;
        const PELLET = 1;
        const POWER_PELLET = 2;
        const EMPTY = 3;
        const GATE = 4; // Ghost house gate

        // Colors
        const COLOR_WALL = '#1919A6'; // Classic Blue
        const COLOR_PELLET = '#FFB897';
        const COLOR_PACMAN = '#FFFF00';
        const COLOR_BG = '#000000';

        // --- RPG Constants ---
        const XP_PER_PELLET = 10;
        const XP_PER_GHOST = 200;
        const BASE_XP_TO_LEVEL = 500;
        const XP_SCALAR = 1.2; // Increase XP requirement by 20% each level


        // --- Map Data (Classic-ish Layout) ---
        // 0: Wall, 1: Pellet, 2: Power, 3: Empty, 4: Gate
        // 28 cols x 31 rows
        const INITIAL_MAP_LAYOUT = [
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
            [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0],
            [0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0],
            [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0],
            [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
            [0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0],
            [0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0],
            [0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0],
            [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
            [3, 3, 3, 3, 3, 0, 1, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 0, 1, 0, 3, 3, 3, 3, 3],
            [3, 3, 3, 3, 3, 0, 1, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 1, 0, 3, 3, 3, 3, 3],
            [3, 3, 3, 3, 3, 0, 1, 0, 0, 3, 0, 0, 4, 4, 4, 4, 0, 0, 3, 0, 0, 1, 0, 3, 3, 3, 3, 3], // 4 is Gate
            [0, 0, 0, 0, 0, 0, 1, 0, 0, 3, 0, 3, 3, 3, 3, 3, 3, 0, 3, 0, 0, 1, 0, 0, 0, 0, 0, 0],
            [3, 3, 3, 3, 3, 3, 1, 3, 3, 3, 0, 3, 3, 3, 3, 3, 3, 0, 3, 3, 3, 1, 3, 3, 3, 3, 3, 3], // Tunnel row (index 14)
            [0, 0, 0, 0, 0, 0, 1, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 1, 0, 0, 0, 0, 0, 0],
            [3, 3, 3, 3, 3, 0, 1, 0, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 1, 0, 3, 3, 3, 3, 3],
            [3, 3, 3, 3, 3, 0, 1, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 1, 0, 3, 3, 3, 3, 3],
            [0, 0, 0, 0, 0, 0, 1, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 1, 0, 0, 0, 0, 0, 0],
            [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
            [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0],
            [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0],
            [0, 2, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 3, 3, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 2, 0], // Pacman spawn around here
            [0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0],
            [0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0],
            [0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0],
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
            [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
            [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] // bottom row buffer
        ];

        // --- Core Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');

        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        // --- Classes ---

        class InputHandler {
            constructor() {
                this.lastKeyPressed = NONE;
                this.mouseX = 0;
                this.mouseY = 0;
                this.mouseClicked = false;

                window.addEventListener('keydown', (e) => {
                    switch (e.code) {
                        case 'ArrowUp': this.lastKeyPressed = UP; break;
                        case 'ArrowDown': this.lastKeyPressed = DOWN; break;
                        case 'ArrowLeft': this.lastKeyPressed = LEFT; break;
                        case 'ArrowRight': this.lastKeyPressed = RIGHT; break;
                    }
                });

                // Mouse Handling for UI
                const canvas = document.getElementById('gameCanvas');
                canvas.addEventListener('mousemove', (e) => {
                    const rect = canvas.getBoundingClientRect();
                    this.mouseX = e.clientX - rect.left;
                    this.mouseY = e.clientY - rect.top;
                });

                canvas.addEventListener('click', () => {
                    this.mouseClicked = true;
                });
            }

            getDirection() {
                return this.lastKeyPressed;
            }

            getMouseStatus() {
                const status = { x: this.mouseX, y: this.mouseY, clicked: this.mouseClicked };
                this.mouseClicked = false; // Reset click
                return status;
            }
        }

        class AudioController {
            constructor() {
                try {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) { console.log('Audio not supported'); }
            }

            playTone(freq, type, duration) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            }

            playChomp() { this.playTone(150, 'triangle', 0.1); }
            playEatGhost() { this.playTone(600, 'square', 0.2); }
            playDie() {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.frequency.setValueAtTime(400, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(50, this.ctx.currentTime + 1);
                gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 1);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 1);
            }
        }

        class Map {
            constructor(layout) {
                this.layout = layout;
            }

            draw(ctx) {
                for (let r = 0; r < GRID_HEIGHT; r++) {
                    for (let c = 0; c < GRID_WIDTH; c++) {
                        let tile = this.layout[r][c];
                        let x = c * TILE_SIZE;
                        let y = r * TILE_SIZE;

                        if (tile === WALL) {
                            // Fancy "Double Line" logic
                            // Actually, let's just draw Blue borders where there is NO neighbor wall
                            ctx.strokeStyle = COLOR_WALL;
                            ctx.lineWidth = 2;
                            ctx.lineCap = 'round';

                            // Check neighbors
                            let nUp = (r > 0) ? this.layout[r - 1][c] : -1;
                            let nDown = (r < GRID_HEIGHT - 1) ? this.layout[r + 1][c] : -1;
                            let nLeft = (c > 0) ? this.layout[r][c - 1] : -1;
                            let nRight = (c < GRID_WIDTH - 1) ? this.layout[r][c + 1] : -1;

                            // If neighbor is NOT Wall (can be Gate), draw line
                            // Double line offset
                            const off = 4;

                            const isWallOrGate = (t) => t === WALL || t === GATE;

                            // Draw outer ring
                            ctx.beginPath();
                            if (!isWallOrGate(nUp)) { ctx.moveTo(x, y + off); ctx.lineTo(x + TILE_SIZE, y + off); }
                            if (!isWallOrGate(nDown)) { ctx.moveTo(x, y + TILE_SIZE - off); ctx.lineTo(x + TILE_SIZE, y + TILE_SIZE - off); }
                            if (!isWallOrGate(nLeft)) { ctx.moveTo(x + off, y); ctx.lineTo(x + off, y + TILE_SIZE); }
                            if (!isWallOrGate(nRight)) { ctx.moveTo(x + TILE_SIZE - off, y); ctx.lineTo(x + TILE_SIZE - off, y + TILE_SIZE); }
                            ctx.stroke();

                            // To make it look connected we need corners... this is getting complex for procedural.
                            // Fallback to "Connected Skeleton"
                            // Draw a Blue Square
                            // Draw a slightly smaller Black Square
                            // "Connect" the black squares if neighbors are walls

                            // 1. Blue Base
                            // Removed: we only want lines.

                            // Let's try the "Hollow Tube" method again but refined.
                            // Fill Blue
                            // Fill Black Center (smaller)
                            // Fill Black Extensions to neighbors

                            ctx.fillStyle = COLOR_WALL;
                            ctx.fillRect(x + 3, y + 3, TILE_SIZE - 6, TILE_SIZE - 6); // Small blue pivot

                            // Extend blue to neighbors
                            if (isWallOrGate(nUp)) ctx.fillRect(x + 3, y, TILE_SIZE - 6, 6);
                            if (isWallOrGate(nDown)) ctx.fillRect(x + 3, y + TILE_SIZE - 6, TILE_SIZE - 6, 6);
                            if (isWallOrGate(nLeft)) ctx.fillRect(x, y + 3, 6, TILE_SIZE - 6);
                            if (isWallOrGate(nRight)) ctx.fillRect(x + TILE_SIZE - 6, y + 3, 6, TILE_SIZE - 6);

                            // Now cut out the center black
                            ctx.fillStyle = 'black';
                            ctx.fillRect(x + 5, y + 5, TILE_SIZE - 10, TILE_SIZE - 10);

                            // Extend black cutout
                            if (isWallOrGate(nUp)) ctx.fillRect(x + 5, y, TILE_SIZE - 10, 5);
                            if (isWallOrGate(nDown)) ctx.fillRect(x + 5, y + TILE_SIZE - 5, TILE_SIZE - 10, 6); // slight overlap
                            if (isWallOrGate(nLeft)) ctx.fillRect(x, y + 5, 5, TILE_SIZE - 10);
                            if (isWallOrGate(nRight)) ctx.fillRect(x + TILE_SIZE - 5, y + 5, 6, TILE_SIZE - 10);

                        } else if (tile === PELLET) {
                            ctx.fillStyle = COLOR_PELLET;
                            ctx.fillRect(x + 7, y + 7, 2, 2); // Smaller pellet
                        } else if (tile === POWER_PELLET) {
                            ctx.fillStyle = COLOR_PELLET;
                            ctx.beginPath();
                            ctx.arc(x + 8, y + 8, 6, 0, Math.PI * 2);
                            ctx.fill();
                        } else if (tile === GATE) {
                            ctx.fillStyle = 'pink';
                            ctx.fillRect(x, y + 7, TILE_SIZE, 2);
                        }
                    }
                }
            }

            isWall(r, c) {
                if (r < 0 || r >= GRID_HEIGHT || c < 0 || c >= GRID_WIDTH) return true; // Bounds check
                return this.layout[r][c] === WALL;
            }

            isGate(r, c) {
                if (r < 0 || r >= GRID_HEIGHT || c < 0 || c >= GRID_WIDTH) return false;
                return this.layout[r][c] === GATE;
            }
        }

        class Pacman {
            constructor(startX, startY, map) {
                this.x = startX * TILE_SIZE;
                this.y = startY * TILE_SIZE;
                this.speed = 2; // Pixels per frame
                this.currentDir = NONE;
                this.nextDir = NONE;
                this.map = map;
                this.mouthOpen = 0;
                this.mouthSpeed = 0.1;
            }

            update(inputDir) {
                if (inputDir !== NONE) {
                    this.nextDir = inputDir;
                }

                // Try to turn
                if (this.nextDir !== NONE && this.canMove(this.nextDir)) {
                    // Only turn if perfectly aligned with grid, OR if we are currently stopped (so we can start moving)
                    if ((this.x % TILE_SIZE === 0 && this.y % TILE_SIZE === 0) || this.currentDir === NONE) {
                        this.currentDir = this.nextDir;
                        this.nextDir = NONE;
                    }
                }

                if (this.canMove(this.currentDir)) {
                    switch (this.currentDir) {
                        case UP: this.y -= this.speed; break;
                        case DOWN: this.y += this.speed; break;
                        case LEFT: this.x -= this.speed; break;
                        case RIGHT: this.x += this.speed; break;
                    }

                    // Wraparound
                    if (this.x < -TILE_SIZE) this.x = CANVAS_WIDTH;
                    if (this.x > CANVAS_WIDTH) this.x = -TILE_SIZE;

                    // Simple animation (mouth)
                    this.mouthOpen += this.mouthSpeed;
                    if (this.mouthOpen > 0.2 || this.mouthOpen < 0) this.mouthSpeed = -this.mouthSpeed;

                    // Audio: Play chomp when mouth closes
                    if (Math.abs(this.mouthOpen) < 0.05 && this.mouthSpeed > 0) {
                        if (game && game.audio) game.audio.playChomp();
                    }

                    // Perk: TRAIL BLAZER
                    if (game.perks.includes('trail_blazer')) {
                        const r = Math.round(this.y / TILE_SIZE);
                        const c = Math.round(this.x / TILE_SIZE);
                        if (!game.fireTiles.find(f => f.r === r && f.c === c)) {
                            game.fireTiles.push({ r, c, life: 4000 });
                        }
                    }

                    // Perk: MAGNETISM
                    if (game.perks.includes('magnetism')) {
                        const magRange = 3; // Tiles
                        // Scan area around pacman
                        let centerR = Math.round(this.y / TILE_SIZE);
                        let centerC = Math.round(this.x / TILE_SIZE);

                        for (let r = centerR - magRange; r <= centerR + magRange; r++) {
                            for (let c = centerC - magRange; c <= centerC + magRange; c++) {
                                if (r >= 0 && r < GRID_HEIGHT && c >= 0 && c < GRID_WIDTH) {
                                    if (this.map.layout[r][c] === PELLET || this.map.layout[r][c] === POWER_PELLET) {
                                        // "Pull" visual isn't easy with grid array.
                                        // For now, simpler: Instant eat if effectively close, or just expand eat radius?
                                        // The prompt says "fly toward Pac-Man".
                                        // To do that, we'd need Pellet objects. Currently map is just integers.
                                        // Compromise: Instant eat in radius (Super Magnet).
                                        // Or, convert integer to "FlyingPellet" object ONLY when in range?
                                        // Let's go with "Vacuum Mode": Eat anything in 3 tile radius immediately.
                                        // Actually, let's make it look cool later if time permits. "Vacuum" is functionally "Magnetism" for grid.

                                        // Dist check
                                        let dist = Math.hypot(c * TILE_SIZE - this.x, r * TILE_SIZE - this.y);
                                        if (dist < magRange * TILE_SIZE) {
                                            // Suck it in
                                            let tile = this.map.layout[r][c];
                                            this.map.layout[r][c] = EMPTY;
                                            if (tile === PELLET) game.pelletEaten(10);
                                            if (tile === POWER_PELLET) {
                                                game.pelletEaten(50);
                                                game.activatePowerMode();
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                    // Eat Pellets (Standard Collision)
                    // Check overlap
                    // Center of pacman vs center of tile
                    if (this.x % TILE_SIZE === 0 && this.y % TILE_SIZE === 0) {
                        let r = this.y / TILE_SIZE;
                        let c = this.x / TILE_SIZE;
                        let tile = this.map.layout[r][c];
                        if (tile === PELLET) {
                            this.map.layout[r][c] = EMPTY;
                            game.pelletEaten(10);
                        } else if (tile === POWER_PELLET) {
                            this.map.layout[r][c] = EMPTY;
                            game.pelletEaten(50);
                            game.activatePowerMode();
                        }
                    }
                }
            }


            canMove(direction) {
                let r = Math.floor(this.y / TILE_SIZE);
                let c = Math.floor(this.x / TILE_SIZE);

                // If not aligned, can only continue in current axis?
                // Actually simplified: check the tile ahead.
                // We need more precise collision to avoid wall clipping.
                // Assuming speed fits into TILE_SIZE (16 % 2 == 0), we check grid alignment.

                let nextR = r;
                let nextC = c;

                if (this.x % TILE_SIZE !== 0 || this.y % TILE_SIZE !== 0) {
                    // Mid-tile, can only continue if direction matches axis
                    if (direction === UP || direction === DOWN) {
                        return (this.x % TILE_SIZE === 0);
                    }
                    if (direction === LEFT || direction === RIGHT) {
                        return (this.y % TILE_SIZE === 0);
                    }
                }

                if (direction === UP) nextR--;
                if (direction === DOWN) nextR++;
                if (direction === LEFT) nextC--;
                if (direction === RIGHT) nextC++;

                if (this.map.isWall(nextR, nextC) || this.map.isGate(nextR, nextC)) {
                    return false;
                }
                return true;
            }

            draw(ctx) {
                ctx.fillStyle = COLOR_PACMAN;
                ctx.beginPath();

                let cx = this.x + TILE_SIZE / 2;
                let cy = this.y + TILE_SIZE / 2;
                let angle = 0;
                if (this.currentDir === UP) angle = -Math.PI / 2;
                if (this.currentDir === DOWN) angle = Math.PI / 2;
                if (this.currentDir === LEFT) angle = Math.PI; // Flip
                if (this.currentDir === RIGHT) angle = 0;

                // Arc
                // If LEFT, 180 deg. Math.PI. 
                // Draw arc from angle + mouth to angle + 2PI - mouth

                let mouth = (this.currentDir === NONE) ? 0 : Math.abs(this.mouthOpen);

                ctx.arc(cx, cy, TILE_SIZE / 2 - 2, angle + mouth * Math.PI, angle + (2 - mouth) * Math.PI);
                ctx.lineTo(cx, cy);
                ctx.fill();
            }
        }

        class Ghost {
            constructor(x, y, color, type, map) {
                this.x = x * TILE_SIZE;
                this.y = y * TILE_SIZE;
                this.color = color;
                this.type = type; // 0: Red, 1: Pink, 2: Cyan, 3: Orange
                this.map = map;
                this.speed = 1; // Normal speed
                this.dir = NONE;
                this.nextDir = NONE;
                // Mode: SCATTER, CHASE, FRIGHTENED, EATEN, HOUSE, EXITING
                this.mode = 'HOUSE';
                // Initial direction inside house (VERTICAL)
                this.dir = [UP, DOWN][Math.floor(Math.random() * 2)];
                this.speedAccumulator = 0;
            }

            update(targetX, targetY) {
                // Wraparound
                if (this.x < -TILE_SIZE) this.x = CANVAS_WIDTH;
                if (this.x > CANVAS_WIDTH) this.x = -TILE_SIZE;

                let currentSpeed = this.speed;
                if (this.mode === 'EATEN') currentSpeed = 4; // Fast eyes
                else if (this.mode === 'FRIGHTENED') currentSpeed = 0.5;

                this.speedAccumulator += currentSpeed;

                while (this.speedAccumulator >= 1) {
                    this.moveStep(targetX, targetY);
                    this.speedAccumulator -= 1;
                    // Optimization: Snap if crossed tile center? 
                    // Existing logic relies on x % TILE_SIZE === 0 checks.
                    // If we move multiple pixels in one frame, we might skip the exact 0 alignment?
                    // moveStep moves 1 pixel.
                    // If we call it multiple times, we move multiple pixels.
                    // It should be fine as long as we don't overshoot turn points.
                    // But moveStep calls decideDirection only at 0.
                    // If we move 2 pixels from -1 to 1, we skip 0.
                    // We must ensure we hit 0. 
                    // Actually, existing logic:
                    // case UP: this.y -= 1;
                    // decision: if (this.x % TILE_SIZE === 0 ...)

                    // If we step 1 by 1, we will hit 0.
                    // So this loop is safe.
                }
            }

            moveStep(targetX, targetY) {
                // Special State Handling (Check BEFORE move)
                if (this.mode === 'HOUSE') {
                    // Bounce logic (Pixel based)
                    // House Y range approx: 13*16 (208) to 15*16 (240)
                    // Keep between 216 (13.5) and 232 (14.5) approx
                    const minY = 13.5 * TILE_SIZE;
                    const maxY = 14.5 * TILE_SIZE;

                    if (this.dir === UP && this.y <= minY) this.dir = DOWN;
                    else if (this.dir === DOWN && this.y >= maxY) this.dir = UP;
                }
                else if (this.mode === 'EXITING') {
                    // Naviagte to Center X then UP
                    const centerX = 13.5 * TILE_SIZE;
                    const exitY = 11 * TILE_SIZE; // Target outside

                    if (Math.abs(this.x - centerX) > 1) {
                        if (this.x < centerX) this.dir = RIGHT;
                        else this.dir = LEFT;
                    } else {
                        this.x = centerX; // Snap X
                        if (this.y > exitY) this.dir = UP;
                        else {
                            // Exited
                            this.mode = 'SCATTER'; // Or global mode
                            this.dir = LEFT; // Break LEFT usually
                            this.y = exitY; // Snap Y
                        }
                    }
                }

                // Apply Movement
                switch (this.dir) {
                    case UP: this.y -= 1; break;
                    case DOWN: this.y += 1; break;
                    case LEFT: this.x -= 1; break;
                    case RIGHT: this.x += 1; break;
                }

                // Regular Grid Decision (SCATTER, CHASE, FRIGHTENED, EATEN)
                // Only at intersection
                if (this.mode !== 'HOUSE' && this.mode !== 'EXITING') {
                    if (this.x % TILE_SIZE === 0 && this.y % TILE_SIZE === 0) {
                        this.decideDirection(targetX, targetY);
                    }
                }
            }

            decideDirection(targetX, targetY) {
                let validDirs = [];

                // Helper to check validity
                const isValid = (d) => {
                    let nr = this.row();
                    let nc = this.col();
                    if (d === UP) nr--;
                    if (d === DOWN) nr++;
                    if (d === LEFT) nc--;
                    if (d === RIGHT) nc++;

                    // Allow Gate if EATEN (Entering)
                    let isGate = this.map.isGate(nr, nc);
                    if (isGate) {
                        if (this.mode === 'EATEN') return true;
                        return false;
                    }

                    return !this.map.isWall(nr, nc);
                };

                // Check all 4 dirs
                if (isValid(UP) && this.dir !== DOWN) validDirs.push(UP);
                if (isValid(DOWN) && this.dir !== UP) validDirs.push(DOWN);
                if (isValid(LEFT) && this.dir !== RIGHT) validDirs.push(LEFT);
                if (isValid(RIGHT) && this.dir !== LEFT) validDirs.push(RIGHT);

                if (validDirs.length === 0) {
                    // Dead end 
                    if (this.dir === UP) this.dir = DOWN;
                    else if (this.dir === DOWN) this.dir = UP;
                    else if (this.dir === LEFT) this.dir = RIGHT;
                    else if (this.dir === RIGHT) this.dir = LEFT;
                    return;
                }

                // Choose best direction based on target
                let bestDir = validDirs[0];
                let minDist = Infinity;

                // Determine target based on mode
                let tx = targetX;
                let ty = targetY;

                if (this.mode === 'SCATTER') {
                    // scatter to corners
                    if (this.type === 0) { tx = CANVAS_WIDTH - TILE_SIZE; ty = 0; } // Top Right
                    else if (this.type === 1) { tx = 0; ty = 0; } // Top Left
                    else if (this.type === 2) { tx = CANVAS_WIDTH; ty = CANVAS_HEIGHT; } // Bottom Right
                    else if (this.type === 3) { tx = 0; ty = CANVAS_HEIGHT; } // Bottom Left
                } else if (this.mode === 'FRIGHTENED') {
                    // Random
                    this.dir = validDirs[Math.floor(Math.random() * validDirs.length)];
                    return; // Done
                } else if (this.mode === 'EATEN') {
                    // Return to inside house (Center)
                    tx = 13.5 * TILE_SIZE;
                    ty = 14 * TILE_SIZE;

                    // Check if we arrived (approx)
                    // Since EATEN eyes travel on grid, they eventually hit 13.5?
                    // No, grid is integers. 13.5 is half.
                    // Closest integer node is (13,11) index outside gate.
                    // We need EATEN to enter gate (13,12) (which is 13.5?)
                    // Gate is at col 13?
                    // Map: 4,4,4,4. Cols 12,13,14,15.
                    // Center is 13.5.
                    // Target: 13.5 * 16.
                    // Standard logic moves on grid lines.
                    // Eyes should target (13.5, 11) (Outside gate).

                    let homeX = 13.5 * TILE_SIZE;
                    let homeY = 11 * TILE_SIZE; // Just outside gate

                    if (Math.abs(this.x - homeX) < TILE_SIZE && Math.abs(this.y - homeY) < TILE_SIZE) {
                        // Arrived at door, enter house mode or force down?
                        // Let's just revive here for simplicity
                        this.mode = 'SCATTER'; // Instant revive at door
                        return;
                    }

                    tx = homeX;
                    ty = homeY;
                }

                validDirs.forEach(d => {
                    let nextX = this.x + (d === LEFT ? -TILE_SIZE : (d === RIGHT ? TILE_SIZE : 0));
                    let nextY = this.y + (d === UP ? -TILE_SIZE : (d === DOWN ? TILE_SIZE : 0));
                    let dist = Math.hypot(nextX - tx, nextY - ty);
                    if (dist < minDist) {
                        minDist = dist;
                        bestDir = d;
                    }
                });

                this.dir = bestDir;
            }

            row() { return Math.round(this.y / TILE_SIZE); }
            col() { return Math.round(this.x / TILE_SIZE); }

            draw(ctx) {
                ctx.fillStyle = this.mode === 'FRIGHTENED' ? '#0000FF' : (this.mode === 'EATEN' ? 'transparent' : this.color);

                let x = this.x;
                let y = this.y;

                if (this.mode !== 'EATEN') {
                    // Ghost Body ( Dome + Feet)
                    ctx.beginPath();
                    ctx.arc(x + TILE_SIZE / 2, y + TILE_SIZE / 2 - 2, TILE_SIZE / 2 - 2, Math.PI, 0);
                    ctx.lineTo(x + TILE_SIZE - 2, y + TILE_SIZE);
                    ctx.lineTo(x + 2, y + TILE_SIZE);
                    ctx.fill();
                }

                // Eyes (always visible)
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(x + 5, y + 6, 3, 0, Math.PI * 2);
                ctx.arc(x + 11, y + 6, 3, 0, Math.PI * 2);
                ctx.fill();

                // Pupils
                ctx.fillStyle = 'blue';
                ctx.beginPath();
                ctx.arc(x + 5 + (this.dir === RIGHT ? 1 : (this.dir === LEFT ? -1 : 0)), y + 6 + (this.dir === DOWN ? 1 : (this.dir === UP ? -1 : 0)), 1.5, 0, Math.PI * 2);
                ctx.arc(x + 11 + (this.dir === RIGHT ? 1 : (this.dir === LEFT ? -1 : 0)), y + 6 + (this.dir === DOWN ? 1 : (this.dir === UP ? -1 : 0)), 1.5, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class Game {
            constructor() {
                this.score = 0;

                // RPG State
                this.level = 1;
                this.xp = 0;
                this.xpMax = BASE_XP_TO_LEVEL;
                this.perks = [];
                this.offeredPerks = [];
                this.fireTiles = [];
                this.projectiles = [];
                this.bulletTimer = 0;

                this.input = new InputHandler();
                this.audio = new AudioController();
                this.map = new Map(JSON.parse(JSON.stringify(INITIAL_MAP_LAYOUT)));
                // Count pellets
                this.pelletCount = 0;
                for (let r = 0; r < GRID_HEIGHT; r++) {
                    for (let c = 0; c < GRID_WIDTH; c++) {
                        if (this.map.layout[r][c] === PELLET || this.map.layout[r][c] === POWER_PELLET) {
                            this.pelletCount++;
                        }
                    }
                }
                this.pacman = new Pacman(13.5, 22, this.map);
                this.lives = 3;

                // Fixed spawn definitions to correct tiles
                this.ghosts = [
                    new Ghost(13.5, 11, 'red', 0, this.map), // Blinky (Outside gate)
                    new Ghost(13.5, 14, 'pink', 1, this.map), // Pinky (Inside)
                    new Ghost(11.5, 14, 'cyan', 2, this.map), // Inky (Inside)
                    new Ghost(15.5, 14, 'orange', 3, this.map) // Clyde (Inside)
                ];

                // Initialize Modes
                this.ghosts[0].mode = 'SCATTER';
                this.ghosts[0].dir = [LEFT, RIGHT][Math.floor(Math.random() * 2)]; // Force horizontal
                this.ghosts[1].mode = 'HOUSE';
                this.ghosts[2].mode = 'HOUSE';
                this.ghosts[3].mode = 'HOUSE';

                this.state = 'READY'; // READY, PLAYING, GAMEOVER, LEVEL_UP

                // RPG State
                this.level = 1;
                this.xp = 0;
                this.xpMax = BASE_XP_TO_LEVEL;
                this.perks = [];
                this.offeredPerks = []; // Perls shown in menu

                this.lastTime = 0;
                this.powerMode = false;
                this.powerTimer = 0;

                // Global Scatter/Chase timer
                this.modeTimer = 0;
                this.globalMode = 'SCATTER';

                // Ghost Release Timer
                this.ghostReleaseTimer = 0;
                this.ghostsReleased = 1; // Blinky is out

                // Listen for Start
                window.addEventListener('keydown', (e) => {
                    if (e.code === 'Space') {
                        if (this.state === 'READY' || this.state === 'GAMEOVER') {
                            this.audio.ctx && this.audio.ctx.resume();
                            this.resetGame();
                            this.state = 'PLAYING';
                        }
                    }
                });
            }

            resetGame() {
                this.score = 0;
                document.getElementById('score').innerText = 0;
                this.lives = 3;
                document.getElementById('lives').innerText = this.lives;

                // Reuse level reset logic to restore map and entities
                this.nextLevel();
            }

            addScore(pts) {
                this.score += pts;
                document.getElementById('score').innerText = this.score;
                this.gainXp(pts); // XP matches score usage mostly
            }

            gainXp(amount) {
                if (this.state !== 'PLAYING') return;
                this.xp += amount;
                if (this.xp >= this.xpMax) {
                    this.triggerLevelUp();
                }
            }

            triggerLevelUp() {
                this.state = 'LEVEL_UP';
                this.xp = this.xp - this.xpMax; // Carry over overflow
                this.xpMax = Math.floor(this.xpMax * XP_SCALAR);
                this.level++;
                this.generatePerkOptions();
            }

            generatePerkOptions() {
                // TODO: Populate this.offeredPerks with actual Perk objects
                // For now placeholders
                this.offeredPerks = [
                    { id: 'trail_blazer', name: 'Trail Blazer', desc: 'Leave a trail of fire.' },
                    { id: 'magnetism', name: 'Magnetism', desc: 'Pellets fly to you.' },
                    { id: 'bullet', name: 'Bullet', desc: 'Shoot ghosts automatically.' }
                ];
            }

            selectPerk(perkId) {
                this.perks.push(perkId);
                console.log("Selected perk:", perkId);
                this.state = 'PLAYING';
            }


            pelletEaten(pts) {
                this.addScore(pts);
                this.pelletCount--;
                if (this.pelletCount <= 0) {
                    setTimeout(() => this.nextLevel(), 500);
                }
            }

            nextLevel() {
                // Restore map
                this.map = new Map(JSON.parse(JSON.stringify(INITIAL_MAP_LAYOUT)));

                // Reset Pellet Count
                this.pelletCount = 0;
                for (let r = 0; r < GRID_HEIGHT; r++) {
                    for (let c = 0; c < GRID_WIDTH; c++) {
                        if (this.map.layout[r][c] === PELLET || this.map.layout[r][c] === POWER_PELLET) {
                            this.pelletCount++;
                        }
                    }
                }

                // Reset entities
                this.softReset();

                // Need to re-bind map to pacman and ghosts since map object changed
                this.pacman.map = this.map;
                this.ghosts.forEach(g => g.map = this.map);
            }

            activatePowerMode() {
                this.powerMode = true;
                clearTimeout(this.powerTimer);
                this.powerTimer = setTimeout(() => {
                    this.powerMode = false;
                    this.ghosts.forEach(g => {
                        if (g.mode === 'FRIGHTENED') g.mode = this.globalMode;
                    });
                }, 8000);

                this.ghosts.forEach(g => {
                    // Don't frighten eaten/house ghosts
                    if (g.mode !== 'EATEN' && g.mode !== 'HOUSE' && g.mode !== 'EXITING') g.mode = 'FRIGHTENED';
                });
            }

            init() {
                requestAnimationFrame((t) => this.loop(t));
            }

            update(dt) {
                if (this.state === 'LEVEL_UP') {
                    this.updateLevelUp(dt);
                    return; // Pause game world
                }

                if (this.state !== 'PLAYING') return;

                // Ghost Release Logic
                this.ghostReleaseTimer += dt;
                if (this.ghostsReleased < 4 && this.ghostReleaseTimer > 5000) { // Release every 5 seconds
                    // Find a ghost in HOUSE
                    let g = this.ghosts.find(gh => gh.mode === 'HOUSE');
                    if (g) {
                        g.mode = 'EXITING';
                        this.ghostsReleased++;
                        this.ghostReleaseTimer = 0;
                    }
                }

                // Mode switching (7s Scatter / 20s Chase simple loop)
                this.modeTimer += dt;
                if (!this.powerMode) {
                    if (this.globalMode === 'SCATTER' && this.modeTimer > 7000) {
                        this.globalMode = 'CHASE';
                        this.modeTimer = 0;
                        this.ghosts.forEach(g => { if (g.mode !== 'EATEN' && g.mode !== 'FRIGHTENED' && g.mode !== 'HOUSE' && g.mode !== 'EXITING') g.mode = 'CHASE'; });
                    } else if (this.globalMode === 'CHASE' && this.modeTimer > 20000) {
                        this.globalMode = 'SCATTER';
                        this.modeTimer = 0;
                        this.ghosts.forEach(g => { if (g.mode !== 'EATEN' && g.mode !== 'FRIGHTENED' && g.mode !== 'HOUSE' && g.mode !== 'EXITING') g.mode = 'SCATTER'; });
                    }
                }

                // Pacman Update with sound trigger check?
                // We need to pass game to pacman or have pacman return event?
                // Easier: Pacman triggers event or access game singleton.
                // Let's modify Pacman class slightly inside Game updater or just check changes.
                // Or just inject Game into Pacman.

                this.pacman.update(this.input.getDirection());
                this.ghosts.forEach(g => g.update(this.pacman.x, this.pacman.y));

                // Collision
                this.ghosts.forEach(g => {
                    let dist = Math.hypot(g.x - this.pacman.x, g.y - this.pacman.y);
                    if (dist < TILE_SIZE) {
                        if (g.mode === 'FRIGHTENED') {
                            g.mode = 'EATEN';
                            this.addScore(200);
                            this.audio.playEatGhost();
                        } else if (g.mode !== 'EATEN') {
                            this.audio.playDie();
                            this.lives--;
                            document.getElementById('lives').innerText = this.lives;
                            if (this.lives > 0) {
                                this.softReset();
                            } else {
                                this.state = 'GAMEOVER';
                            }
                        }
                    }
                });
                if (this.fireTiles.length > 0) {
                    for (let i = this.fireTiles.length - 1; i >= 0; i--) {
                        let f = this.fireTiles[i];
                        f.life -= dt;
                        if (f.life <= 0) {
                            this.fireTiles.splice(i, 1);
                        } else {
                            // Ghost Damage
                            this.ghosts.forEach(g => {
                                let gr = Math.round(g.y / TILE_SIZE);
                                let gc = Math.round(g.x / TILE_SIZE);
                                if (gr === f.r && gc === f.c && g.mode !== 'EATEN' && g.mode !== 'FRIGHTENED') {
                                    // Burn ghost
                                    this.audio.playEatGhost();
                                    g.mode = 'EATEN';
                                    this.addScore(200);
                                }
                            });
                        }
                    }
                }

                // Update Projectiles (Bullet)
                // Shoot Trigger
                if (this.perks.includes('bullet') && this.state === 'PLAYING') {
                    this.bulletTimer += dt;
                    if (this.bulletTimer > 2000) { // 2 Seconds
                        this.bulletTimer = 0;
                        this.shootBullet();
                    }
                }

                // Move Projectiles
                if (this.projectiles.length > 0) {
                    for (let i = this.projectiles.length - 1; i >= 0; i--) {
                        let p = this.projectiles[i];
                        p.x += p.dx * 8; // Fast speed
                        p.y += p.dy * 8;

                        // Wall Collision
                        let r = Math.floor(p.y / TILE_SIZE);
                        let c = Math.floor(p.x / TILE_SIZE);
                        if (this.map.isWall(r, c)) {
                            this.projectiles.splice(i, 1);
                            continue;
                        }

                        // Ghost Collision
                        let hit = false;
                        for (let g of this.ghosts) {
                            if (g.mode === 'EATEN') continue;
                            let dist = Math.hypot(g.x - p.x, g.y - p.y);
                            if (dist < TILE_SIZE) {
                                g.mode = 'EATEN';
                                this.addScore(200);
                                this.audio.playEatGhost();
                                this.projectiles.splice(i, 1);
                                hit = true;
                                break;
                            }
                        }
                    }
                }
            }

            updateLevelUp(dt) {
                const mouse = this.input.getMouseStatus();
                if (!mouse.clicked) return;

                const cardWidth = 120;
                const cardHeight = 160;
                const gap = 20;
                const totalWidth = 3 * cardWidth + 2 * gap;
                const startX = (CANVAS_WIDTH - totalWidth) / 2;
                const startY = 150;

                this.offeredPerks.forEach((perk, index) => {
                    const x = startX + index * (cardWidth + gap);
                    const y = startY;

                    if (mouse.x >= x && mouse.x <= x + cardWidth && mouse.y >= y && mouse.y <= y + cardHeight) {
                        this.selectPerk(perk.id);
                    }
                });
            }

            // NOTE: We need to trigger chomp sound.
            // In Pacman.update, we can assume if it moved, we chomp.
            // But doing it here is messy.
            // I will update Pacman class via a separate tool call if needed or just patch it.
            // Actually, I can rely on a simple interval for "wakka wakka" if moving.

            shootBullet() {
                // Find nearest ghost
                let nearest = null;
                let minDst = Infinity;

                this.ghosts.forEach(g => {
                    if (g.mode === 'EATEN') return;
                    let dst = Math.hypot(g.x - this.pacman.x, g.y - this.pacman.y);
                    if (dst < minDst) {
                        minDst = dst;
                        nearest = g;
                    }
                });

                if (nearest) {
                    let dx = nearest.x - this.pacman.x;
                    let dy = nearest.y - this.pacman.y;
                    let len = Math.hypot(dx, dy);
                    if (len > 0) {
                        dx /= len;
                        dy /= len;
                        this.projectiles.push({ x: this.pacman.x + TILE_SIZE / 2, y: this.pacman.y + TILE_SIZE / 2, dx, dy });
                    }
                }
            }

            draw() {
                ctx.fillStyle = COLOR_BG;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                this.map.draw(ctx);

                // Draw Fire
                ctx.fillStyle = 'rgba(255, 69, 0, 0.6)'; // OrangeRed transparent
                this.fireTiles.forEach(f => {
                    ctx.fillRect(f.c * TILE_SIZE, f.r * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    // Flicker center
                    if (Math.random() > 0.5) {
                        ctx.fillStyle = 'rgba(255, 215, 0, 0.8)';
                        ctx.fillRect(f.c * TILE_SIZE + 4, f.r * TILE_SIZE + 4, TILE_SIZE - 8, TILE_SIZE - 8);
                        ctx.fillStyle = 'rgba(255, 69, 0, 0.6)'; // Reset
                    }
                });

                // Draw Projectiles
                ctx.fillStyle = '#FFF';
                this.projectiles.forEach(p => {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                    ctx.fill();
                });

                this.pacman.draw(ctx);
                this.ghosts.forEach(g => g.draw(ctx));

                // UI Overlay
                if (this.state === 'READY') {
                    ctx.fillStyle = 'yellow';
                    ctx.font = '20px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillText("PRESS SPACE TO START", canvas.width / 2, canvas.height / 2 + 20);
                } else if (this.state === 'GAMEOVER') {
                    ctx.fillStyle = 'red';
                    ctx.font = '30px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2);
                    ctx.fillText("Press Space to Restart", canvas.width / 2, canvas.height / 2 + 30);
                } else if (this.state === 'LEVEL_UP') {
                    this.drawLevelUpMenu(ctx);
                }

                this.drawXpBar(ctx);
            }

            drawXpBar(ctx) {
                const barHeight = 10;
                const barWidth = CANVAS_WIDTH;
                const fillPercent = Math.min(1, this.xp / this.xpMax);

                // Background
                ctx.fillStyle = '#333';
                ctx.fillRect(0, CANVAS_HEIGHT - barHeight, barWidth, barHeight);

                // Fill
                ctx.fillStyle = '#00FF00'; // Green XP
                ctx.fillRect(0, CANVAS_HEIGHT - barHeight, barWidth * fillPercent, barHeight);

                // Text
                ctx.fillStyle = 'white';
                ctx.font = '10px monospace';
                ctx.textAlign = 'left';
                ctx.fillText(`LVL ${this.level}`, 5, CANVAS_HEIGHT - 12);
            }

            drawLevelUpMenu(ctx) {
                // Overlay
                ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.font = '30px monospace';
                ctx.fillText('LEVEL UP!', CANVAS_WIDTH / 2, 80);

                ctx.font = '16px monospace';
                ctx.fillText('Choose a Perk:', CANVAS_WIDTH / 2, 110);

                // Draw Cards
                const cardWidth = 120;
                const cardHeight = 160;
                const gap = 20;
                const totalWidth = 3 * cardWidth + 2 * gap;
                const startX = (CANVAS_WIDTH - totalWidth) / 2;
                const startY = 150;

                this.offeredPerks.forEach((perk, index) => {
                    const x = startX + index * (cardWidth + gap);
                    const y = startY;

                    // Highlight
                    const mouse = this.input.getMouseStatus();
                    const mx = this.input.mouseX; // Peek
                    const my = this.input.mouseY;
                    const hovered = mx >= x && mx <= x + cardWidth && my >= y && my <= y + cardHeight;

                    // Card Bg
                    ctx.fillStyle = hovered ? '#444' : '#222';
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.fillRect(x, y, cardWidth, cardHeight);
                    ctx.strokeRect(x, y, cardWidth, cardHeight);

                    // Title
                    ctx.fillStyle = '#FFFF00';
                    ctx.font = '14px monospace';
                    ctx.fillText(perk.name, x + cardWidth / 2, y + 30);

                    // Desc
                    ctx.fillStyle = '#DDD';
                    ctx.font = '12px monospace';
                    this.wrapText(ctx, perk.desc, x + cardWidth / 2, y + 60, cardWidth - 10, 16);
                });
            }

            wrapText(ctx, text, x, y, maxWidth, lineHeight) {
                const words = text.split(' ');
                let line = '';
                for (let n = 0; n < words.length; n++) {
                    const testLine = line + words[n] + ' ';
                    const metrics = ctx.measureText(testLine);
                    const testWidth = metrics.width;
                    if (testWidth > maxWidth && n > 0) {
                        ctx.fillText(line, x, y);
                        line = words[n] + ' ';
                        y += lineHeight;
                    }
                    else {
                        line = testLine;
                    }
                }
                ctx.fillText(line, x, y);
            }


            loop(timestamp) {
                const dt = timestamp - this.lastTime;
                this.lastTime = timestamp;

                this.update(dt);
                this.draw();

                requestAnimationFrame((t) => this.loop(t));
            }

            softReset() {
                // Difficulty Scaling
                // Base speed 1. Increase by 10% per level. Cap at 2.0 (Pacman speed).
                const diffMultiplier = 1 + (this.level - 1) * 0.1;
                const newSpeed = Math.min(2.0, 1 * diffMultiplier);

                // Reset Ghosts positions & modes
                this.ghosts = [
                    new Ghost(13.5, 11, 'red', 0, this.map),
                    new Ghost(13.5, 14, 'pink', 1, this.map),
                    new Ghost(11.5, 14, 'cyan', 2, this.map),
                    new Ghost(15.5, 14, 'orange', 3, this.map)
                ];

                // Apply speed
                this.ghosts.forEach(g => g.speed = newSpeed);

                this.ghosts[0].mode = 'SCATTER';
                this.ghosts[0].dir = [LEFT, RIGHT][Math.floor(Math.random() * 2)]; // Force Blinky Horizontal

                this.pacman = new Pacman(13.5, 22, this.map);

                this.ghostsReleased = 1;
                this.ghostReleaseTimer = 0;
                this.modeTimer = 0;
                this.globalMode = 'SCATTER';
                this.powerMode = false;
                clearTimeout(this.powerTimer);

                // Keep Projectiles? Probably clear them on level reset to be fair.
                this.projectiles = [];
                // Keep Fire? Maybe clear fire tiles too.
                this.fireTiles = [];
            }
        }

        // --- Initialization ---
        const game = new Game();
        game.init();

    </script>
</body>

</html>