<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pac-Man Arcade Clone</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: #fff;
            font-family: 'Courier New', Courier, monospace;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 20px rgba(33, 33, 255, 0.5);
            border: 4px solid #2121ff;
            border-radius: 8px;
        }

        canvas {
            display: block;
        }

        #ui {
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 10px 20px;
            box-sizing: border-box;
            font-size: 20px;
            pointer-events: none;
            background: #000;
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        h1 {
            font-size: 48px;
            color: #ffff00;
            margin-bottom: 20px;
        }

        p {
            font-size: 24px;
            margin-top: 10px;
        }

        .blink {
            animation: blinker 1s linear infinite;
        }

        @keyframes blinker {
            50% {
                opacity: 0;
            }
        }

        /* XP Bar Styles */
        #xp-container {
            width: 200px;
            height: 12px;
            background: #333;
            border: 2px solid #fff;
            border-radius: 6px;
            position: relative;
            overflow: hidden;
            margin: 0 10px;
        }

        #xp-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #00cc00);
            transition: width 0.3s ease;
        }

        #level-display {
            font-weight: bold;
            color: #00ff00;
        }

        /* Menu Styles */
        #menu-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }

        .menu-grid {
            display: flex;
            gap: 30px;
            margin-top: 30px;
        }

        .menu-item {
            width: 200px;
            height: 250px;
            background: #111;
            border: 4px solid #222;
            border-radius: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            overflow: hidden;
        }

        .menu-item:hover {
            transform: translateY(-10px);
            border-color: #ffff00;
            box-shadow: 0 10px 30px rgba(255, 255, 0, 0.3);
        }

        .menu-item img {
            width: 120px;
            height: 120px;
            margin-bottom: 20px;
            image-rendering: pixelated;
        }

        /* Mock images for now using CSS shapes */
        .icon {
            width: 80px;
            height: 80px;
            margin-bottom: 20px;
        }

        .icon-pacman {
            background: #ffff00;
            border-radius: 50%;
            clip-path: polygon(100% 0, 100% 100%, 50% 50%, 100% 0, 0 0, 0 100%, 100% 100%);
        }

        .icon-galaga {
            width: 0;
            height: 0;
            border-left: 40px solid transparent;
            border-right: 40px solid transparent;
            border-bottom: 80px solid #ff0000;
            position: relative;
        }

        .icon-galaga::after {
            content: '';
            position: absolute;
            left: -20px;
            top: 40px;
            width: 40px;
            height: 20px;
            background: #ffffff;
        }

        .menu-item span {
            font-size: 24px;
            color: #fff;
            font-weight: bold;
            text-transform: uppercase;
        }

        .menu-title {
            font-size: 48px;
            color: #2121ff;
            text-shadow: 0 0 10px #2121ff;
            margin-bottom: 10px;
        }

        /* Perk Overlay Styles (Restored) */
        #perk-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        #perk-container {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }

        .perk-card {
            width: 140px;
            height: 200px;
            background: #111;
            border: 2px solid #ffff00;
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: transform 0.2s, background 0.2s;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .perk-card:hover {
            transform: scale(1.05);
            background: #222;
            box-shadow: 0 0 15px rgba(255, 255, 0, 0.5);
        }

        .perk-title {
            font-size: 18px;
            color: #ffff00;
            font-weight: bold;
        }

        .perk-desc {
            font-size: 14px;
            color: #fff;
            margin-top: 10px;
        }

        .perk-rarity {
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
        }
    </style>
</head>

<body>

    <div id="game-container">
        <!-- Game Selection Menu -->
        <div id="menu-overlay">
            <h1 class="menu-title">ARCADE HUB</h1>
            <p>SELECT YOUR GAME</p>
            <div class="menu-grid">
                <div class="menu-item" onclick="startGame('pacman')">
                    <div class="icon icon-pacman"></div>
                    <span>Pac-Man</span>
                </div>
                <div class="menu-item" onclick="startGame('galaga')">
                    <div class="icon icon-galaga"></div>
                    <span>Galaga</span>
                </div>
            </div>
        </div>

        <div id="ui">
            <div>SCORE: <span id="score">0</span></div>
            <div>HI-SCORE: <span id="high-score">0</span></div>
            <div id="pacman-xp-ui" style="display: flex; align-items: center;">
                LVL: <span id="level-display">1</span>
                <div id="xp-container">
                    <div id="xp-bar"></div>
                </div>
            </div>
            <div>LIVES: <span id="lives">3</span></div>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div id="overlay">
            <h1 id="overlay-title">PAC-MAN RPG</h1>
            <p id="overlay-msg" class="blink">PRESS SPACE TO START</p>
        </div>
        <div id="perk-overlay">
            <h1>LEVEL UP!</h1>
            <p>CHOOSE A PERK</p>
            <div id="perk-container"></div>
        </div>
    </div>

    <script>
        /**
         * CONSTANTS & GAME DATA
         */
        const TILE_SIZE = 16;
        const ROWS = 31;
        const COLS = 28;
        const CANVAS_WIDTH = COLS * TILE_SIZE;
        const CANVAS_HEIGHT = ROWS * TILE_SIZE;

        const COLORS = {
            WALL: '#2121ff',
            PELLET: '#ffb8ae',
            POWER_PELLET: '#ffb8ae',
            PACMAN: '#ffff00',
            GHOST_RED: '#ff0000',
            GHOST_PINK: '#ffb8ff',
            GHOST_CYAN: '#00ffff',
            GHOST_ORANGE: '#ffb852',
            GHOST_SCARED: '#2121ff',
            GHOST_EYES: '#ffffff'
        };

        const DIRECTIONS = {
            NONE: { x: 0, y: 0 },
            UP: { x: 0, y: -1 },
            DOWN: { x: 0, y: 1 },
            LEFT: { x: -1, y: 0 },
            RIGHT: { x: 1, y: 0 }
        };

        // Map Representation:
        // 0: Empty, 1: Wall, 2: Pellet, 3: Power Pellet, 4: Ghost House, 5: Portal
        const MAP_TEMPLATE = [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],
            [1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1],
            [1, 3, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 3, 1],
            [1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1],
            [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],
            [1, 2, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 2, 1],
            [1, 2, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 2, 1],
            [1, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 1],
            [1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1],
            [0, 0, 0, 0, 0, 1, 2, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 2, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 1, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 2, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 1, 2, 1, 1, 0, 1, 1, 1, 4, 4, 1, 1, 1, 0, 1, 1, 2, 1, 0, 0, 0, 0, 0],
            [1, 1, 1, 1, 1, 1, 2, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 2, 1, 1, 1, 1, 1, 1],
            [5, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 0, 0, 5],
            [1, 1, 1, 1, 1, 1, 2, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 2, 1, 1, 1, 1, 1, 1],
            [0, 0, 0, 0, 0, 1, 2, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 2, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 1, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 2, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 1, 2, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 2, 1, 0, 0, 0, 0, 0],
            [1, 1, 1, 1, 1, 1, 2, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 2, 1, 1, 1, 1, 1, 1],
            [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],
            [1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1],
            [1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1],
            [1, 3, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 0, 0, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 3, 1],
            [1, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 1],
            [1, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 1],
            [1, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 1],
            [1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1],
            [1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1],
            [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        ];

        let MAP_LAYOUT = [];

        /**
         * UTILS
         */
        function getTile(x, y) {
            const row = Math.floor(y / TILE_SIZE);
            const col = Math.floor(x / TILE_SIZE);
            // Handle row 14 portals explicitly
            if (row === 14 && (col < 0 || col >= COLS)) return 5;
            // Strict wall for all other out of bounds
            if (row < 0 || row >= ROWS || col < 0 || col >= COLS) return 1;
            return MAP_LAYOUT[row][col];
        }

        function isWall(x, y, entity = null) {
            const tile = getTile(x, y);
            if (tile === 4) { // Ghost House Gate
                if (entity instanceof Ghost) {
                    if (entity.mode === 'EATEN') return false;
                    // Allow exit (moving UP from below the gate at row 12)
                    if (entity.y > y && entity.getTilePos().row >= 12) return false;
                }
                return true; // Wall for Pac-Man and ghosts trying to enter (if not eaten)
            }
            return tile === 1;
        }

        /**
         * SOUND ENGINE (Oscillators)
         */
        const AudioCtx = window.AudioContext || window.webkitAudioContext;
        let audioCtx = null;

        function playSound(freq, type, duration) {
            if (!audioCtx) audioCtx = new AudioCtx();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            osc.start();
            osc.stop(audioCtx.currentTime + duration);
        }

        /**
         * ENTITY CLASS
         */
        class Entity {
            constructor(x, y, speed) {
                this.x = x * TILE_SIZE + TILE_SIZE / 2;
                this.y = y * TILE_SIZE + TILE_SIZE / 2;
                this.speed = speed;
                this.dir = DIRECTIONS.LEFT;
                this.nextDir = DIRECTIONS.LEFT;
                this.radius = TILE_SIZE / 2 - 2;
            }

            getTilePos() {
                return {
                    row: Math.floor(this.y / TILE_SIZE),
                    col: Math.floor(this.x / TILE_SIZE)
                };
            }

            canMove(dir) {
                const margin = 2;
                let checkX = this.x + dir.x * (TILE_SIZE / 2 + margin);
                let checkY = this.y + dir.y * (TILE_SIZE / 2 + margin);

                // Handle portal wrap around for collision check pre-logic
                if (checkX < 0) checkX = CANVAS_WIDTH - 1;
                if (checkX >= CANVAS_WIDTH) checkX = 0;

                const isGhost = this instanceof Ghost;
                return !isWall(checkX, checkY, this);
            }

            isAtIntersection() {
                // Increase tolerance to ensure intersection is caught even at high speeds
                const centerX = (Math.floor(this.x / TILE_SIZE) + 0.5) * TILE_SIZE;
                const centerY = (Math.floor(this.y / TILE_SIZE) + 0.5) * TILE_SIZE;
                const tolerance = this.speed + 0.1;
                return Math.abs(this.x - centerX) < tolerance / 2 &&
                    Math.abs(this.y - centerY) < tolerance / 2;
            }

            snapToTile() {
                this.x = (Math.floor(this.x / TILE_SIZE) + 0.5) * TILE_SIZE;
                this.y = (Math.floor(this.y / TILE_SIZE) + 0.5) * TILE_SIZE;
            }
        }

        /**
         * PAC-MAN CLASS
         */
        class Pacman extends Entity {
            constructor() {
                super(13.5, 23, 2);
                this.mouthOpen = 0;
                this.mouthSpeed = 0.1;
                this.trail = [];
                this.bulletTimer = 0;
                this.magnetizedPellets = [];
            }

            update() {
                // Buffered Input handling
                if (this.isAtIntersection()) {
                    if (this.canMove(this.nextDir)) {
                        this.dir = this.nextDir;
                        this.snapToTile();
                    }
                }

                if (this.canMove(this.dir)) {
                    this.x += this.dir.x * this.speed;
                    this.y += this.dir.y * this.speed;
                    this.mouthOpen += this.mouthSpeed;
                    if (this.mouthOpen > 0.2 || this.mouthOpen < 0) this.mouthSpeed *= -1;
                } else {
                    this.snapToTile();
                }

                // Portal wrap around
                if (this.x < 0) this.x = CANVAS_WIDTH;
                if (this.x > CANVAS_WIDTH) this.x = 0;

                // Perk: Trail Blazer
                if (game.perks.includes('Trail Blazer')) {
                    if (game.frameCount % 5 === 0) {
                        this.trail.push({ x: this.x, y: this.y, life: 180 }); // 3 seconds at 60fps
                    }
                }
                this.trail = this.trail.filter(p => {
                    p.life--;
                    return p.life > 0;
                });

                // Perk: Bullet
                if (game.perks.includes('Bullet')) {
                    this.bulletTimer++;
                    if (this.bulletTimer >= 120) { // 2 seconds
                        this.shoot();
                        this.bulletTimer = 0;
                    }
                }

                // Perk: Magnetism
                if (game.perks.includes('Magnetism')) {
                    this.applyMagnetism();
                }

                this.eat();
            }

            applyMagnetism() {
                const range = TILE_SIZE * 3;
                const pos = this.getTilePos();
                // Check nearby tiles to "magnetize" pellets
                for (let r = pos.row - 3; r <= pos.row + 3; r++) {
                    for (let c = pos.col - 3; c <= pos.col + 3; c++) {
                        if (r >= 0 && r < ROWS && c >= 0 && c < COLS) {
                            if (MAP_LAYOUT[r][c] === 2 || MAP_LAYOUT[r][c] === 3) {
                                const pelletX = c * TILE_SIZE + TILE_SIZE / 2;
                                const pelletY = r * TILE_SIZE + TILE_SIZE / 2;
                                const d = Math.hypot(this.x - pelletX, this.y - pelletY);
                                if (d < range) {
                                    const type = MAP_LAYOUT[r][c];
                                    MAP_LAYOUT[r][c] = 0;
                                    this.magnetizedPellets.push({
                                        x: pelletX,
                                        y: pelletY,
                                        type: type
                                    });
                                }
                            }
                        }
                    }
                }

                // Move magnetized pellets towards Pac-Man
                this.magnetizedPellets = this.magnetizedPellets.filter(p => {
                    const d = Math.hypot(this.x - p.x, this.y - p.y);
                    if (d < 5) { // Eat it
                        const value = p.type === 3 ? 50 : 10;
                        game.score += value;
                        game.addXp(value);
                        if (p.type === 3) game.frightenGhosts();
                        playSound(440, 'sine', 0.05);
                        return false;
                    }
                    // Lerp towards Pac-Man
                    p.x += (this.x - p.x) * 0.15;
                    p.y += (this.y - p.y) * 0.15;
                    return true;
                });
            }

            shoot() {
                let nearest = null;
                let minDist = Infinity;
                game.ghosts.forEach(g => {
                    if (g.mode !== 'EATEN') {
                        const d = Math.hypot(this.x - g.x, this.y - g.y);
                        if (d < minDist) {
                            minDist = d;
                            nearest = g;
                        }
                    }
                });

                if (nearest) {
                    const angle = Math.atan2(nearest.y - this.y, nearest.x - this.x);
                    game.projectiles.push({
                        x: this.x,
                        y: this.y,
                        vx: Math.cos(angle) * 5,
                        vy: Math.sin(angle) * 5,
                        radius: 4
                    });
                    playSound(1200, 'square', 0.05);
                }
            }

            eat() {
                const pos = this.getTilePos();
                const tile = MAP_LAYOUT[pos.row][pos.col];
                if (tile === 2) { // Pellet
                    MAP_LAYOUT[pos.row][pos.col] = 0;
                    game.score += 10;
                    game.addXp(10);
                    playSound(440, 'sine', 0.05);
                } else if (tile === 3) { // Power Pellet
                    MAP_LAYOUT[pos.row][pos.col] = 0;
                    game.score += 50;
                    game.addXp(50);
                    game.frightenGhosts();
                    playSound(880, 'square', 0.1);
                }
            }

            draw(ctx) {
                // Draw magnetized pellets
                this.magnetizedPellets.forEach(p => {
                    ctx.fillStyle = COLORS.PELLET;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.type === 3 ? 5 : 2, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Draw Trail
                ctx.fillStyle = 'rgba(255, 69, 0, 0.5)';
                this.trail.forEach(p => {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, this.radius * 0.8, 0, Math.PI * 2);
                    ctx.fill();
                });

                ctx.fillStyle = COLORS.PACMAN;
                ctx.beginPath();
                let angle = 0;
                if (this.dir === DIRECTIONS.RIGHT) angle = 0;
                if (this.dir === DIRECTIONS.LEFT) angle = Math.PI;
                if (this.dir === DIRECTIONS.UP) angle = -Math.PI / 2;
                if (this.dir === DIRECTIONS.DOWN) angle = Math.PI / 2;

                ctx.moveTo(this.x, this.y);
                ctx.arc(this.x, this.y, this.radius, angle + this.mouthOpen * Math.PI, angle + (2 - this.mouthOpen) * Math.PI);
                ctx.fill();
            }
        }

        /**
         * GHOST CLASS
         */
        class Ghost extends Entity {
            constructor(x, y, color, id) {
                super(x, y, 1.8);
                this.color = color;
                this.id = id;
                this.mode = 'CHASE'; // CHASE, SCATTER, FRIGHTENED, EATEN
                this.baseSpeed = 1.8;
                this.scaredSpeed = 1.0;
                this.eatenSpeed = 4.0;
                this.startX = x * TILE_SIZE + TILE_SIZE / 2;
                this.startY = y * TILE_SIZE + TILE_SIZE / 2;
                this.timer = 0;
            }

            update(pacman) {
                if (this.mode === 'FRIGHTENED') this.speed = this.scaredSpeed;
                else if (this.mode === 'EATEN') this.speed = this.eatenSpeed;
                else this.speed = this.baseSpeed;

                // Return to house center if eaten
                if (this.mode === 'EATEN') {
                    const houseCenterX = 13.5 * TILE_SIZE;
                    const houseCenterY = 14 * TILE_SIZE;
                    const dist = Math.hypot(this.x - houseCenterX, this.y - houseCenterY);
                    if (dist < TILE_SIZE / 2) {
                        this.mode = 'CHASE';
                    }
                }

                if (this.isAtIntersection()) {
                    this.snapToTile();
                    this.chooseDirection(pacman);
                }

                if (this.canMove(this.dir)) {
                    this.x += this.dir.x * this.speed;
                    this.y += this.dir.y * this.speed;
                } else {
                    this.snapToTile();
                    // If blocked, force a direction change at next frame
                    this.chooseDirection(pacman);
                }

                // Portal wrap at row 14 only
                if (Math.floor(this.y / TILE_SIZE) === 14) {
                    if (this.x < -TILE_SIZE) this.x = CANVAS_WIDTH + TILE_SIZE / 2;
                    if (this.x > CANVAS_WIDTH + TILE_SIZE) this.x = -TILE_SIZE / 2;
                } else {
                    // Clamp to screen for other rows to prevent disappearing
                    this.x = Math.max(TILE_SIZE / 2, Math.min(CANVAS_WIDTH - TILE_SIZE / 2, this.x));
                    this.y = Math.max(TILE_SIZE / 2, Math.min(CANVAS_HEIGHT - TILE_SIZE / 2, this.y));
                }

                // Recovery: if somehow x/y are NaN, reset to start
                if (isNaN(this.x) || isNaN(this.y)) {
                    this.x = this.startX;
                    this.y = this.startY;
                    this.mode = 'CHASE';
                    console.error('Ghost NaN recovery triggered', this.id);
                }

                // Removal of old EATEN recovery check here as it's replaced or handled in update start
                // (The previous check was at the end of update, moving logic flow up slightly)
            }

            chooseDirection(pacman) {
                const possibleDirs = [DIRECTIONS.UP, DIRECTIONS.LEFT, DIRECTIONS.DOWN, DIRECTIONS.RIGHT];
                let bestDir = null;
                let minDist = Infinity;

                // Filter out reverse direction (ghosts don't normally turn back)
                const filteredDirs = possibleDirs.filter(d => {
                    if (d.x === -this.dir.x && d.y === -this.dir.y) return false;
                    return this.canMove(d);
                });

                if (filteredDirs.length === 0) {
                    // Dead end, must turn back
                    this.dir = { x: -this.dir.x, y: -this.dir.y };
                    return;
                }

                if (this.mode === 'FRIGHTENED') {
                    this.dir = filteredDirs[Math.floor(Math.random() * filteredDirs.length)];
                    return;
                }

                let targetX, targetY;
                if (this.mode === 'EATEN') {
                    targetX = 13.5 * TILE_SIZE;
                    targetY = 14 * TILE_SIZE;
                } else if ((getTile(this.x, this.y) === 4 || (this.y > 12 * TILE_SIZE && this.y < 16 * TILE_SIZE && this.x > 10 * TILE_SIZE && this.x < 18 * TILE_SIZE)) && this.mode !== 'EATEN') {
                    // Force exit from house
                    targetX = 13.5 * TILE_SIZE;
                    targetY = 11 * TILE_SIZE;
                    // Move towards the horizontal center first, then UP
                    if (Math.abs(this.x - targetX) > 2) {
                        targetY = this.y; // Focus on horizontal alignment
                    }
                } else {
                    // Simplistic target AI
                    targetX = pacman.x;
                    targetY = pacman.y;

                    // Add some personality
                    if (this.id === 1) { // Pinky looks ahead
                        targetX += pacman.dir.x * TILE_SIZE * 4;
                        targetY += pacman.dir.y * TILE_SIZE * 4;
                    } else if (this.id === 2) { // Inky is tricky (randomish target)
                        if (Math.random() > 0.5) { targetX = 0; targetY = 0; }
                    } else if (this.id === 3) { // Clyde is shy
                        const d = Math.hypot(this.x - pacman.x, this.y - pacman.y);
                        if (d < TILE_SIZE * 8) { targetX = 0; targetY = CANVAS_HEIGHT; }
                    }
                }

                filteredDirs.forEach(d => {
                    const nextX = this.x + d.x * TILE_SIZE;
                    const nextY = this.y + d.y * TILE_SIZE;
                    const dist = Math.hypot(nextX - targetX, nextY - targetY);
                    if (dist < minDist) {
                        minDist = dist;
                        bestDir = d;
                    }
                });

                // If inside the ghost house, force UP direction ONLY if not eaten
                const tile = getTile(this.x, this.y);
                if (tile === 4 && this.mode !== 'EATEN') {
                    this.dir = DIRECTIONS.UP;
                    return;
                }

                this.dir = bestDir || this.dir;
            }

            draw(ctx) {
                ctx.fillStyle = this.mode === 'FRIGHTENED' ? COLORS.GHOST_SCARED : this.color;
                if (this.mode === 'EATEN') ctx.fillStyle = 'rgba(255,255,255,0.2)';

                // Ghost Body
                ctx.beginPath();
                ctx.arc(this.x, this.y - 2, this.radius, Math.PI, 0);
                ctx.lineTo(this.x + this.radius, this.y + this.radius);
                ctx.lineTo(this.x - this.radius, this.y + this.radius);
                ctx.fill();

                // Eyes
                ctx.fillStyle = COLORS.GHOST_EYES;
                ctx.beginPath();
                ctx.arc(this.x - 4, this.y - 4, 3, 0, Math.PI * 2);
                ctx.arc(this.x + 4, this.y - 4, 3, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(this.x - 4 + this.dir.x * 2, this.y - 4 + this.dir.y * 2, 1.5, 0, Math.PI * 2);
                ctx.arc(this.x + 4 + this.dir.x * 2, this.y - 4 + this.dir.y * 2, 1.5, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        /**
         * PERK DEFINITIONS
         */
        const ALL_PERKS = [
            { id: 'Trail Blazer', title: 'Trail Blazer', desc: 'Leave a trail of fire that damages ghosts.' },
            { id: 'Magnetism', title: 'Magnetism', desc: 'Pellets within 3 tiles fly toward you.' },
            { id: 'Bullet', title: 'Bullet', desc: 'Shoot a projectile at ghosts every 2s.' }
        ];

        /**
         * GAME ENGINE
         */
        /**
         * PAC-MAN GAME ENGINE
         */
        class PacManGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.canvas.width = CANVAS_WIDTH;
                this.canvas.height = CANVAS_HEIGHT;

                this.score = 0;
                this.highScore = 0;
                this.lives = 3;
                this.state = 'START'; // START, PLAYING, LEVEL_UP, GAMEOVER
                this.frightenedTimer = 0;
                this.xp = 0;
                this.level = 1;
                this.maxXp = 500;
                this.perks = [];
                this.projectiles = [];
                this.difficultyCycle = 1;
                this.frameCount = 0;

                window.game = this;
                this.init();
                this.bindEvents();
            }

            init() {
                this.pacman = new Pacman();
                this.ghosts = [
                    new Ghost(13.5, 11, COLORS.GHOST_RED, 0),
                    new Ghost(13.5, 14, COLORS.GHOST_PINK, 1),
                    new Ghost(11.5, 14, COLORS.GHOST_CYAN, 2),
                    new Ghost(15.5, 14, COLORS.GHOST_ORANGE, 3)
                ];
                this.ghosts[0].dir = DIRECTIONS.LEFT; // Red ghost starts moving
                this.ghosts[1].dir = DIRECTIONS.UP;   // Others move up to exit
                this.ghosts[2].dir = DIRECTIONS.UP;
                this.ghosts[3].dir = DIRECTIONS.UP;

                // Reset map data
                MAP_LAYOUT = JSON.parse(JSON.stringify(MAP_TEMPLATE));

                this.totalPellets = this.countPellets();
            }

            countPellets() {
                let count = 0;
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        if (MAP_LAYOUT[r][c] === 2 || MAP_LAYOUT[r][c] === 3) {
                            count++;
                        }
                    }
                }
                return count;
            }

            bindEvents() {
                this._onKeyDown = (e) => {
                    if (this.state === 'START' || this.state === 'GAMEOVER') {
                        if (e.code === 'Space') this.start();
                        return;
                    }

                    switch (e.key) {
                        case 'ArrowUp': this.pacman.nextDir = DIRECTIONS.UP; break;
                        case 'ArrowDown': this.pacman.nextDir = DIRECTIONS.DOWN; break;
                        case 'ArrowLeft': this.pacman.nextDir = DIRECTIONS.LEFT; break;
                        case 'ArrowRight': this.pacman.nextDir = DIRECTIONS.RIGHT; break;
                    }
                };
                window.addEventListener('keydown', this._onKeyDown);
            }

            start() {
                this.state = 'PLAYING';
                this.score = 0;
                this.lives = 3;
                this.init();
                document.getElementById('overlay').style.display = 'none';
                document.getElementById('lives').innerText = this.lives;
                this.loop();
            }

            resetRound() {
                this.pacman.x = 13.5 * TILE_SIZE + TILE_SIZE / 2;
                this.pacman.y = 23 * TILE_SIZE + TILE_SIZE / 2;
                this.pacman.dir = DIRECTIONS.LEFT;
                this.pacman.nextDir = DIRECTIONS.LEFT;
                this.pacman.trail = [];
                this.pacman.magnetizedPellets = [];
                this.projectiles = [];

                const ghostStarts = [
                    { x: 13.5, y: 11 },
                    { x: 13.5, y: 14 },
                    { x: 11.5, y: 14 },
                    { x: 15.5, y: 14 }
                ];
                this.ghosts.forEach((g, i) => {
                    g.x = ghostStarts[i].x * TILE_SIZE + TILE_SIZE / 2;
                    g.y = ghostStarts[i].y * TILE_SIZE + TILE_SIZE / 2;
                    g.mode = 'CHASE';
                    g.dir = i === 0 ? DIRECTIONS.LEFT : DIRECTIONS.UP;
                    g.baseSpeed = 1.8 * (1 + (this.difficultyCycle - 1) * 0.1);
                });
            }

            addXp(amount) {
                this.xp += amount;
                if (this.xp >= this.maxXp) {
                    this.levelUp();
                }
                this.updateXpBar();
            }

            updateXpBar() {
                const percent = (this.xp / this.maxXp) * 100;
                document.getElementById('xp-bar').style.width = `${percent}%`;
                document.getElementById('level-display').innerText = this.level;
            }

            levelUp() {
                this.xp = 0;
                this.level++;
                this.maxXp = Math.floor(this.maxXp * 2.0);
                this.state = 'LEVEL_UP';
                this.showPerkMenu();
                playSound(660, 'square', 0.2);
                playSound(880, 'square', 0.2);
            }

            showPerkMenu() {
                const overlay = document.getElementById('perk-overlay');
                const container = document.getElementById('perk-container');
                container.innerHTML = '';
                overlay.style.display = 'flex';

                // Randomly pick 3 perks
                const shuffled = ALL_PERKS.sort(() => 0.5 - Math.random());
                const selection = shuffled.slice(0, 3);

                selection.forEach(perk => {
                    const card = document.createElement('div');
                    card.className = 'perk-card';
                    card.innerHTML = `
                        <div class="perk-title">${perk.title}</div>
                        <div class="perk-desc">${perk.desc}</div>
                        <div class="perk-rarity">Common</div>
                    `;
                    card.onclick = () => this.selectPerk(perk.id);
                    container.appendChild(card);
                });
            }

            selectPerk(perkId) {
                this.perks.push(perkId);
                document.getElementById('perk-overlay').style.display = 'none';
                this.state = 'PLAYING';
                this.loop();
            }

            gameOver() {
                this.state = 'GAMEOVER';
                if (this.score > this.highScore) this.highScore = this.score;
                document.getElementById('high-score').innerText = this.highScore;
                document.getElementById('overlay-title').innerText = 'GAME OVER';
                document.getElementById('overlay-msg').innerText = 'PRESS SPACE TO RESTART';
                document.getElementById('overlay').style.display = 'flex';
                playSound(110, 'sawtooth', 0.5);
            }

            frightenGhosts() {
                this.frightenedTimer = 400; // ~7 seconds at 60fps
                this.ghosts.forEach(g => {
                    if (g.mode !== 'EATEN') g.mode = 'FRIGHTENED';
                });
            }

            update() {
                if (this.state !== 'PLAYING') return;

                this.pacman.update();

                if (this.frightenedTimer > 0) {
                    this.frightenedTimer--;
                    if (this.frightenedTimer === 0) {
                        this.ghosts.forEach(g => { if (g.mode === 'FRIGHTENED') g.mode = 'CHASE'; });
                    }
                }

                this.ghosts.forEach(ghost => {
                    ghost.update(this.pacman);

                    // Collision Detection: Pacman vs Ghost
                    const dist = Math.hypot(this.pacman.x - ghost.x, this.pacman.y - ghost.y);
                    if (dist < TILE_SIZE) {
                        if (ghost.mode === 'FRIGHTENED') {
                            ghost.mode = 'EATEN';
                            this.score += 200;
                            this.addXp(50);
                            playSound(1320, 'sine', 0.1);
                        } else if (ghost.mode === 'CHASE' || ghost.mode === 'SCATTER') {
                            this.lives--;
                            document.getElementById('lives').innerText = this.lives;
                            if (this.lives > 0) {
                                this.resetRound();
                            } else {
                                this.gameOver();
                            }
                            return;
                        }
                    }

                    // Collision Detection: Ghost vs Trail
                    if (this.pacman.trail.some(p => Math.hypot(p.x - ghost.x, p.y - ghost.y) < TILE_SIZE / 2)) {
                        if (ghost.mode !== 'EATEN') {
                            ghost.mode = 'EATEN';
                            this.score += 100;
                            this.addXp(20);
                            playSound(1000, 'sine', 0.05);
                        }
                    }
                });

                // Projectile Updates
                this.projectiles = this.projectiles.filter(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    let hit = false;
                    this.ghosts.forEach(g => {
                        if (g.mode !== 'EATEN' && Math.hypot(p.x - g.x, p.y - g.y) < TILE_SIZE) {
                            g.mode = 'EATEN';
                            this.score += 100;
                            this.addXp(20);
                            hit = true;
                            playSound(1000, 'sine', 0.05);
                        }
                    });
                    return !hit && p.x > 0 && p.x < CANVAS_WIDTH && p.y > 0 && p.y < CANVAS_HEIGHT;
                });

                // Check for Level Clear
                if (this.countPellets() === 0) {
                    this.difficultyCycle++;
                    this.resetRound(); // Reset entities and board
                    MAP_LAYOUT = JSON.parse(JSON.stringify(MAP_TEMPLATE));
                    playSound(660, 'square', 0.2);
                    playSound(880, 'square', 0.2);
                }

                this.frameCount++;
                document.getElementById('score').innerText = this.score;
            }

            draw() {
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                this.drawMap();
                this.drawProjectiles();
                this.pacman.draw(this.ctx);
                this.ghosts.forEach(g => g.draw(this.ctx));
            }

            drawProjectiles() {
                this.ctx.fillStyle = '#fff';
                this.projectiles.forEach(p => {
                    this.ctx.beginPath();
                    this.ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                });
            }

            drawMap() {
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        const tile = MAP_LAYOUT[r][c];
                        const x = c * TILE_SIZE;
                        const y = r * TILE_SIZE;

                        if (tile === 1) { // Wall
                            this.ctx.strokeStyle = COLORS.WALL;
                            this.ctx.lineWidth = 2;
                            this.ctx.strokeRect(x + 2, y + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                        } else if (tile === 2) { // Pellet
                            this.ctx.fillStyle = COLORS.PELLET;
                            this.ctx.beginPath();
                            this.ctx.arc(x + TILE_SIZE / 2, y + TILE_SIZE / 2, 2, 0, Math.PI * 2);
                            this.ctx.fill();
                        } else if (tile === 3) { // Power Pellet
                            this.ctx.fillStyle = COLORS.POWER_PELLET;
                            this.ctx.beginPath();
                            this.ctx.arc(x + TILE_SIZE / 2, y + TILE_SIZE / 2, 5, 0, Math.PI * 2);
                            this.ctx.fill();
                        } else if (tile === 4) { // Ghost House Gate
                            this.ctx.fillStyle = '#ffb8ff';
                            this.ctx.fillRect(x, y + TILE_SIZE / 2 - 1, TILE_SIZE, 2);
                        }
                    }
                }
            }

            loop() {
                if (this.state !== 'PLAYING') return;
                this.update();
                this.draw();
                this.requestId = requestAnimationFrame(() => this.loop());
            }

            stop() {
                if (this.requestId) cancelAnimationFrame(this.requestId);
                window.removeEventListener('keydown', this._onKeyDown);
            }
        }

        /**
         * GALAGA GAME ENGINE
         */
        class GalagaGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.canvas.width = 448; // Classic vertical aspect ratio
                this.canvas.height = 512;

                this.score = 0;
                this.lives = 3;
                this.state = 'PLAYING'; // PLAYING, GAMEOVER
                this.ship = new GalagaShip(this.canvas.width / 2, this.canvas.height - 40);
                this.bullets = [];
                this.enemyBullets = [];
                this.enemies = [];
                this.stars = [];
                this.frameCount = 0;

                window.game = this;
                this.init();
                this.bindEvents();
            }

            init() {
                // Create stars
                for (let i = 0; i < 100; i++) {
                    this.stars.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        speed: 0.5 + Math.random() * 2,
                        color: `rgb(${Math.random() * 255}, ${Math.random() * 255}, 255)`
                    });
                }
                this.spawnSwarm();
            }

            spawnSwarm() {
                const cols = 8;
                const rows = 4;
                const spacingX = 40;
                const spacingY = 30;
                const startX = (this.canvas.width - (cols - 1) * spacingX) / 2;
                const startY = 80;

                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        this.enemies.push(new GalagaEnemy(
                            startX + c * spacingX,
                            startY + r * spacingY,
                            r === 0 ? 'commander' : (r === 1 ? 'red' : 'blue')
                        ));
                    }
                }
            }

            bindEvents() {
                this.keyState = {};
                this._onKeyDown = (e) => {
                    this.keyState[e.code] = true;
                    if (e.code === 'Space' && this.state === 'PLAYING') {
                        this.shoot();
                    }
                    if (e.code === 'Space' && this.state === 'GAMEOVER') {
                        location.reload(); // Simple way to restart for now
                    }
                };
                this._onKeyUp = (e) => this.keyState[e.code] = false;

                window.addEventListener('keydown', this._onKeyDown);
                window.addEventListener('keyup', this._onKeyUp);
            }

            shoot() {
                if (this.bullets.length < 2) {
                    this.bullets.push({ x: this.ship.x, y: this.ship.y - 10 });
                    playSound(880, 'square', 0.05);
                }
            }

            update() {
                if (this.state !== 'PLAYING') return;

                // Move Stars
                this.stars.forEach(s => {
                    s.y += s.speed;
                    if (s.y > this.canvas.height) s.y = 0;
                });

                // Move Ship
                if (this.keyState['ArrowLeft'] && this.ship.x > 20) this.ship.x -= 4;
                if (this.keyState['ArrowRight'] && this.ship.x < this.canvas.width - 20) this.ship.x += 4;

                // Move Bullets
                this.bullets.forEach((b, i) => {
                    b.y -= 8;
                    if (b.y < 0) this.bullets.splice(i, 1);
                });

                // Move Enemy Bullets
                this.enemyBullets.forEach((b, i) => {
                    b.y += 4;
                    if (b.y > this.canvas.height) this.enemyBullets.splice(i, 1);

                    // Check Collision with Ship
                    if (Math.hypot(b.x - this.ship.x, b.y - this.ship.y) < 15) {
                        this.enemyBullets.splice(i, 1);
                        this.hitShip();
                    }
                });

                // Move Enemies & Collisions
                let swarmDirection = Math.sin(this.frameCount * 0.02) * 20;
                this.enemies.forEach((en, i) => {
                    en.update(swarmDirection);

                    // Shooting
                    if (Math.random() < 0.002 && en.state === 'FORM') {
                        this.enemyBullets.push({ x: en.x, y: en.y });
                    }

                    // Bullet Collision
                    this.bullets.forEach((b, bi) => {
                        if (Math.hypot(b.x - en.x, b.y - en.y) < 15) {
                            this.enemies.splice(i, 1);
                            this.bullets.splice(bi, 1);
                            this.score += en.points;
                            playSound(440, 'sawtooth', 0.1);
                        }
                    });

                    // Ship Collision
                    if (Math.hypot(en.x - this.ship.x, en.y - this.ship.y) < 20) {
                        this.hitShip();
                    }
                });

                if (this.enemies.length === 0) this.spawnSwarm();

                this.frameCount++;
                document.getElementById('score').innerText = this.score;
            }

            hitShip() {
                this.lives--;
                document.getElementById('lives').innerText = this.lives;
                playSound(100, 'sawtooth', 0.5);
                if (this.lives <= 0) {
                    this.state = 'GAMEOVER';
                    const hiScoreEl = document.getElementById('high-score');
                    if (this.score > parseInt(hiScoreEl.innerText)) {
                        hiScoreEl.innerText = this.score;
                    }
                    document.getElementById('overlay-title').innerText = 'GAME OVER';
                    document.getElementById('overlay-msg').innerText = 'PRESS SPACE TO RESTART';
                    document.getElementById('overlay').style.display = 'flex';
                } else {
                    this.ship.x = this.canvas.width / 2;
                }
            }

            draw() {
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Stars
                this.stars.forEach(s => {
                    this.ctx.fillStyle = s.color;
                    this.ctx.fillRect(s.x, s.y, 2, 2);
                });

                // Ship
                this.ship.draw(this.ctx);

                // Bullets
                this.ctx.fillStyle = '#fff';
                this.bullets.forEach(b => this.ctx.fillRect(b.x - 1, b.y, 2, 8));
                this.ctx.fillStyle = '#f00';
                this.enemyBullets.forEach(b => this.ctx.fillRect(b.x - 1, b.y, 2, 8));

                // Enemies
                this.enemies.forEach(en => en.draw(this.ctx));
            }

            loop() {
                this.update();
                this.draw();
                this.requestId = requestAnimationFrame(() => this.loop());
            }

            stop() {
                if (this.requestId) cancelAnimationFrame(this.requestId);
                window.removeEventListener('keydown', this._onKeyDown);
                window.removeEventListener('keyup', this._onKeyUp);
            }
        }

        class GalagaShip {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }
            draw(ctx) {
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.moveTo(this.x, this.y - 15);
                ctx.lineTo(this.x + 15, this.y + 15);
                ctx.lineTo(this.x - 15, this.y + 15);
                ctx.fill();
                ctx.fillStyle = '#f00';
                ctx.fillRect(this.x - 5, this.y, 10, 15);
            }
        }

        class GalagaEnemy {
            constructor(x, y, type) {
                this.baseX = x;
                this.baseY = y;
                this.x = x;
                this.y = y;
                this.type = type;
                this.state = 'FORM'; // FORM, DIVE
                this.points = type === 'commander' ? 150 : (type === 'red' ? 80 : 50);
                this.color = type === 'commander' ? '#00f' : (type === 'red' ? '#f00' : '#0f0');
            }
            update(offsetX) {
                this.x = this.baseX + offsetX;
            }
            draw(ctx) {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y + 10);
                ctx.lineTo(this.x + 10, this.y - 10);
                ctx.lineTo(this.x - 10, this.y - 10);
                ctx.fill();
            }
        }

        /**
         * GLOBAL CONTROLLER
         */
        let currentGame = null;

        function startGame(type) {
            if (currentGame) currentGame.stop();
            document.getElementById('menu-overlay').style.display = 'none';
            document.getElementById('overlay').style.display = 'none';

            // UI visibility handling
            if (type === 'pacman') {
                document.getElementById('pacman-xp-ui').style.display = 'flex';
                currentGame = new PacManGame();
                currentGame.start();
            } else {
                document.getElementById('pacman-xp-ui').style.display = 'none';
                currentGame = new GalagaGame();
                currentGame.loop();
            }
        }

    </script>
</body>

</html>