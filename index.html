<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pac-Man</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
        }

        #gameContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #scoreBoard {
            color: #fff;
            font-size: 18px;
            margin-bottom: 10px;
            width: 448px;
            display: flex;
            justify-content: space-between;
        }

        #gameCanvas {
            border: 2px solid #2121ff;
            image-rendering: pixelated;
        }

        #message {
            color: #ffff00;
            font-size: 24px;
            margin-top: 20px;
            text-align: center;
        }

        #xpContainer {
            width: 448px;
            margin-top: 5px;
        }

        #xpBar {
            width: 100%;
            height: 12px;
            background: linear-gradient(to bottom, #1a1a2e, #0f0f1a);
            border: 2px solid #4a4a8a;
            border-radius: 6px;
            overflow: hidden;
            position: relative;
        }

        #xpFill {
            height: 100%;
            background: linear-gradient(to right, #6a0dad, #9b4dca, #c77dff);
            width: 0%;
            transition: width 0.3s ease-out;
            box-shadow: 0 0 10px #9b4dca;
        }

        #xpText {
            color: #c77dff;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
            margin-top: 2px;
        }

        /* Perk Selection Overlay */
        #perkOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 1000;
        }

        #perkTitle {
            color: #ffd700;
            font-size: 32px;
            text-shadow: 0 0 20px #ffd700;
            margin-bottom: 30px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }
        }

        #perkCards {
            display: flex;
            gap: 25px;
        }

        .perk-card {
            width: 180px;
            height: 250px;
            background: linear-gradient(145deg, rgba(30, 30, 60, 0.9), rgba(10, 10, 30, 0.95));
            border: 2px solid rgba(150, 100, 255, 0.5);
            border-radius: 15px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }

        .perk-card:hover {
            transform: translateY(-10px) scale(1.05);
            border-color: #ffd700;
            box-shadow: 0 20px 40px rgba(255, 215, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        .perk-icon {
            font-size: 50px;
            margin-bottom: 10px;
        }

        .perk-name {
            color: #fff;
            font-size: 16px;
            font-weight: bold;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .perk-desc {
            color: #aaa;
            font-size: 12px;
            text-align: center;
            line-height: 1.4;
        }

        .perk-card.trail-blazer {
            border-top: 4px solid #ff6b35;
        }

        .perk-card.magnetism {
            border-top: 4px solid #00d4ff;
        }

        .perk-card.bullet {
            border-top: 4px solid #ffdd00;
        }

        /* Wave Notification */
        #waveNotification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffd700;
            font-size: 48px;
            text-shadow: 0 0 30px #ffd700;
            display: none;
            animation: waveIn 2s ease-out forwards;
            z-index: 100;
        }

        @keyframes waveIn {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.5);
            }

            50% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.2);
            }

            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        /* Active Perks Display */
        #activePerks {
            color: #aaa;
            font-size: 11px;
            margin-top: 5px;
            width: 448px;
        }
    </style>
</head>

<body>
    <div id="gameContainer">
        <div id="scoreBoard">
            <span>SCORE: <span id="score">0</span></span>
            <span>HIGH SCORE: <span id="highScore">0</span></span>
            <span>LIVES: <span id="lives">3</span></span>
        </div>
        <canvas id="gameCanvas" width="448" height="496"></canvas>
        <div id="xpContainer">
            <div id="xpBar">
                <div id="xpFill"></div>
            </div>
            <div id="xpText">
                <span>Level <span id="level">1</span></span>
                <span>XP: <span id="currentXp">0</span> / <span id="xpNeeded">100</span></span>
            </div>
        </div>
        <div id="activePerks">Perks: None</div>
        <div id="message">PRESS SPACE TO START</div>
        <div id="waveNotification"></div>
    </div>

    <!-- Perk Selection Overlay -->
    <div id="perkOverlay">
        <div id="perkTitle">‚≠ê LEVEL UP! ‚≠ê</div>
        <div id="perkCards"></div>
    </div>

    <script>
        // ==================== CONSTANTS ====================
        const TILE_SIZE = 16;
        const GRID_WIDTH = 28;
        const GRID_HEIGHT = 31;
        const CANVAS_WIDTH = TILE_SIZE * GRID_WIDTH;
        const CANVAS_HEIGHT = TILE_SIZE * GRID_HEIGHT;

        // Colors
        const COLORS = {
            WALL: '#2121ff',
            PELLET: '#ffb8ae',
            POWER_PELLET: '#ffb8ae',
            PACMAN: '#ffff00',
            GHOST_RED: '#ff0000',
            GHOST_PINK: '#ffb8ff',
            GHOST_CYAN: '#00ffff',
            GHOST_ORANGE: '#ffb852',
            GHOST_VULNERABLE: '#2121ff',
            GHOST_FLASH: '#ffffff',
            BACKGROUND: '#000000',
            TEXT: '#ffffff'
        };

        // Speeds (pixels per frame at 60fps) - 30% slower
        const PACMAN_SPEED = 1.4;
        const GHOST_SPEED = 1.26;
        const GHOST_VULNERABLE_SPEED = 0.7;
        const GHOST_RETURNING_SPEED = 2.0;

        // Directions
        const DIRECTIONS = {
            NONE: { x: 0, y: 0 },
            UP: { x: 0, y: -1 },
            DOWN: { x: 0, y: 1 },
            LEFT: { x: -1, y: 0 },
            RIGHT: { x: 1, y: 0 }
        };

        // Scoring
        const POINTS = {
            PELLET: 10,
            POWER_PELLET: 50,
            GHOST: 200
        };

        // Timers
        const POWER_PELLET_DURATION = 8000; // ms
        const GHOST_FLASH_TIME = 2000; // ms before power ends

        // XP System
        const XP_PER_PELLET = 5;
        const XP_PER_POWER_PELLET = 25;
        const XP_PER_GHOST = 50;
        const BASE_XP_TO_LEVEL = 100;
        const XP_LEVEL_MULTIPLIER = 1.5; // Each level needs 50% more XP

        // Perk Definitions
        const PERKS = {
            TRAIL_BLAZER: {
                id: 'TRAIL_BLAZER',
                name: 'Trail Blazer',
                desc: 'Leave a trail of fire that damages ghosts',
                icon: 'üî•'
            },
            MAGNETISM: {
                id: 'MAGNETISM',
                name: 'Magnetism',
                desc: 'Pellets within 3 tiles fly toward you',
                icon: 'üß≤'
            },
            BULLET: {
                id: 'BULLET',
                name: 'Bullet',
                desc: 'Auto-shoot at the nearest ghost every 2 seconds',
                icon: 'üéØ'
            }
        };

        // Perk Settings
        const FIRE_TRAIL_DURATION = 2000; // ms
        const MAGNETISM_RADIUS = 3; // tiles
        const BULLET_INTERVAL = 2000; // ms
        const BULLET_SPEED = 4; // pixels per frame
        const PROJECTILE_DAMAGE = true; // Ghosts hit by projectiles start returning

        // ==================== MAP DATA ====================
        // 0 = empty, 1 = wall, 2 = pellet, 3 = power pellet, 4 = ghost house
        const MAP_DATA = [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],
            [1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1],
            [1, 3, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 3, 1],
            [1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1],
            [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],
            [1, 2, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 2, 1],
            [1, 2, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 2, 1],
            [1, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 1],
            [1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1],
            [0, 0, 0, 0, 0, 1, 2, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 2, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 1, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 2, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 1, 2, 1, 1, 0, 1, 1, 1, 4, 4, 1, 1, 1, 0, 1, 1, 2, 1, 0, 0, 0, 0, 0],
            [1, 1, 1, 1, 1, 1, 2, 1, 1, 0, 1, 4, 4, 4, 4, 4, 4, 1, 0, 1, 1, 2, 1, 1, 1, 1, 1, 1],
            [0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 1, 4, 4, 4, 4, 4, 4, 1, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0],
            [1, 1, 1, 1, 1, 1, 2, 1, 1, 0, 1, 4, 4, 4, 4, 4, 4, 1, 0, 1, 1, 2, 1, 1, 1, 1, 1, 1],
            [0, 0, 0, 0, 0, 1, 2, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 2, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 1, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 2, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 1, 2, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 2, 1, 0, 0, 0, 0, 0],
            [1, 1, 1, 1, 1, 1, 2, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 2, 1, 1, 1, 1, 1, 1],
            [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],
            [1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1],
            [1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 1],
            [1, 3, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 0, 0, 2, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 3, 1],
            [1, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 1],
            [1, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 2, 1, 1, 1],
            [1, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 2, 2, 1],
            [1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1],
            [1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1],
            [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        ];

        // ==================== AUDIO ====================
        class AudioManager {
            constructor() {
                this.audioContext = null;
                this.initialized = false;
            }

            init() {
                if (this.initialized) return;
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.initialized = true;
                } catch (e) {
                    console.log('Web Audio API not supported');
                }
            }

            playSound(type) {
                if (!this.initialized || !this.audioContext) return;

                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                switch (type) {
                    case 'chomp':
                        oscillator.type = 'sawtooth';
                        oscillator.frequency.setValueAtTime(200, this.audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(100, this.audioContext.currentTime + 0.1);
                        gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
                        oscillator.start();
                        oscillator.stop(this.audioContext.currentTime + 0.1);
                        break;
                    case 'powerPellet':
                        oscillator.type = 'sine';
                        oscillator.frequency.setValueAtTime(400, this.audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(800, this.audioContext.currentTime + 0.2);
                        gainNode.gain.setValueAtTime(0.15, this.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
                        oscillator.start();
                        oscillator.stop(this.audioContext.currentTime + 0.2);
                        break;
                    case 'eatGhost':
                        oscillator.type = 'square';
                        oscillator.frequency.setValueAtTime(600, this.audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(1200, this.audioContext.currentTime + 0.3);
                        gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
                        oscillator.start();
                        oscillator.stop(this.audioContext.currentTime + 0.3);
                        break;
                    case 'death':
                        oscillator.type = 'sawtooth';
                        oscillator.frequency.setValueAtTime(500, this.audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(50, this.audioContext.currentTime + 1);
                        gainNode.gain.setValueAtTime(0.15, this.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 1);
                        oscillator.start();
                        oscillator.stop(this.audioContext.currentTime + 1);
                        break;
                }
            }
        }

        // ==================== MAP CLASS ====================
        class GameMap {
            constructor() {
                this.grid = JSON.parse(JSON.stringify(MAP_DATA));
                this.totalPellets = 0;
                this.pelletsEaten = 0;
                this.countPellets();
            }

            reset() {
                this.grid = JSON.parse(JSON.stringify(MAP_DATA));
                this.pelletsEaten = 0;
                this.countPellets();
            }

            countPellets() {
                this.totalPellets = 0;
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    for (let x = 0; x < GRID_WIDTH; x++) {
                        if (this.grid[y][x] === 2 || this.grid[y][x] === 3) {
                            this.totalPellets++;
                        }
                    }
                }
            }

            getTile(x, y) {
                if (x < 0 || x >= GRID_WIDTH || y < 0 || y >= GRID_HEIGHT) {
                    return 0; // Treat out of bounds as empty for tunnel
                }
                return this.grid[y][x];
            }

            isWall(x, y) {
                const tile = this.getTile(x, y);
                return tile === 1;
            }

            isWalkable(x, y) {
                const tile = this.getTile(x, y);
                return tile !== 1;
            }

            eatPellet(x, y) {
                // Bounds check for tunnel positions
                if (x < 0 || x >= GRID_WIDTH || y < 0 || y >= GRID_HEIGHT) {
                    return 0;
                }
                const tile = this.grid[y][x];
                if (tile === 2 || tile === 3) {
                    this.grid[y][x] = 0;
                    this.pelletsEaten++;
                    return tile;
                }
                return 0;
            }

            allPelletsEaten() {
                return this.pelletsEaten >= this.totalPellets;
            }

            draw(ctx) {
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    for (let x = 0; x < GRID_WIDTH; x++) {
                        const tile = this.grid[y][x];
                        const px = x * TILE_SIZE;
                        const py = y * TILE_SIZE;

                        if (tile === 1) {
                            // Draw wall with double-line effect
                            ctx.strokeStyle = COLORS.WALL;
                            ctx.lineWidth = 2;

                            // Check neighbors to draw appropriate wall segments
                            const top = y > 0 && this.grid[y - 1][x] === 1;
                            const bottom = y < GRID_HEIGHT - 1 && this.grid[y + 1][x] === 1;
                            const left = x > 0 && this.grid[y][x - 1] === 1;
                            const right = x < GRID_WIDTH - 1 && this.grid[y][x + 1] === 1;

                            ctx.beginPath();
                            if (!top && !bottom && !left && !right) {
                                // Isolated wall
                                ctx.strokeRect(px + 2, py + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                            } else {
                                // Draw connected wall segments
                                const cx = px + TILE_SIZE / 2;
                                const cy = py + TILE_SIZE / 2;

                                if (top) {
                                    ctx.moveTo(cx, cy);
                                    ctx.lineTo(cx, py);
                                }
                                if (bottom) {
                                    ctx.moveTo(cx, cy);
                                    ctx.lineTo(cx, py + TILE_SIZE);
                                }
                                if (left) {
                                    ctx.moveTo(cx, cy);
                                    ctx.lineTo(px, cy);
                                }
                                if (right) {
                                    ctx.moveTo(cx, cy);
                                    ctx.lineTo(px + TILE_SIZE, cy);
                                }
                            }
                            ctx.stroke();
                        } else if (tile === 2) {
                            // Draw pellet
                            ctx.fillStyle = COLORS.PELLET;
                            ctx.beginPath();
                            ctx.arc(px + TILE_SIZE / 2, py + TILE_SIZE / 2, 2, 0, Math.PI * 2);
                            ctx.fill();
                        } else if (tile === 3) {
                            // Draw power pellet (blinking)
                            if (Math.floor(Date.now() / 200) % 2 === 0) {
                                ctx.fillStyle = COLORS.POWER_PELLET;
                                ctx.beginPath();
                                ctx.arc(px + TILE_SIZE / 2, py + TILE_SIZE / 2, 6, 0, Math.PI * 2);
                                ctx.fill();
                            }
                        }
                    }
                }
            }
        }

        // ==================== PACMAN CLASS ====================
        class Pacman {
            constructor() {
                this.reset();
            }

            reset() {
                this.x = 14 * TILE_SIZE + TILE_SIZE / 2;
                this.y = 23 * TILE_SIZE + TILE_SIZE / 2;
                this.direction = DIRECTIONS.NONE;
                this.nextDirection = DIRECTIONS.NONE;
                this.mouthAngle = 0;
                this.mouthOpening = true;
                this.speed = PACMAN_SPEED;
            }

            update(map) {
                // Animate mouth
                if (this.mouthOpening) {
                    this.mouthAngle += 0.15;
                    if (this.mouthAngle >= 0.4) this.mouthOpening = false;
                } else {
                    this.mouthAngle -= 0.15;
                    if (this.mouthAngle <= 0) this.mouthOpening = true;
                }

                // Try to change direction if we have a buffered input
                if (this.nextDirection !== DIRECTIONS.NONE) {
                    // Check if the next tile in the buffered direction is walkable
                    const canTurn = this.canTurnToDirection(this.nextDirection, map);
                    const nearCenter = this.isNearTileCenter();

                    // Determine if this is a perpendicular turn
                    const isPerpendicular = (
                        (this.direction.x !== 0 && this.nextDirection.y !== 0) ||
                        (this.direction.y !== 0 && this.nextDirection.x !== 0)
                    );



                    // For perpendicular turns, require being near tile center AND tile being walkable
                    if (canTurn && nearCenter) {
                        // Snap to tile center on BOTH axes when making perpendicular turns
                        // This ensures the hitbox is fully aligned and won't clip into adjacent walls
                        if (isPerpendicular) {
                            this.snapToTileCenter('both');

                        }

                        // Final check: verify we can actually move in the new direction after snapping
                        if (this.canMove(this.nextDirection, map)) {
                            this.direction = this.nextDirection;
                            this.nextDirection = DIRECTIONS.NONE;

                        } else {

                        }
                    }
                    // Keep nextDirection buffered if we can't turn yet
                }

                // Move in current direction (continue moving even if buffered direction is blocked)
                const canMoveCurrent = this.direction !== DIRECTIONS.NONE && this.canMove(this.direction, map);
                const dirName = this.getDirectionName(this.direction);
                const nextDirName = this.getDirectionName(this.nextDirection);

                if (canMoveCurrent) {
                    this.x += this.direction.x * this.speed;
                    this.y += this.direction.y * this.speed;
                } else if (this.direction !== DIRECTIONS.NONE) {

                }

                // Handle tunnel wrapping
                if (this.x < -TILE_SIZE / 2) {
                    this.x = CANVAS_WIDTH - TILE_SIZE / 2;
                } else if (this.x > CANVAS_WIDTH - TILE_SIZE / 2) {
                    this.x = -TILE_SIZE / 2;
                }
            }

            canMove(direction, map) {
                // Check if Pac-Man can move in the given direction
                const nextX = this.x + direction.x * this.speed;
                const nextY = this.y + direction.y * this.speed;

                // Get the corners of Pac-Man's hitbox
                const halfSize = TILE_SIZE / 2 - 2;
                const corners = [
                    { x: nextX - halfSize, y: nextY - halfSize },
                    { x: nextX + halfSize, y: nextY - halfSize },
                    { x: nextX - halfSize, y: nextY + halfSize },
                    { x: nextX + halfSize, y: nextY + halfSize }
                ];

                for (const corner of corners) {
                    const tileX = Math.floor(corner.x / TILE_SIZE);
                    const tileY = Math.floor(corner.y / TILE_SIZE);
                    if (map.isWall(tileX, tileY)) {
                        return false;
                    }
                }
                return true;
            }

            // Check if the tile in the given direction from current tile is walkable
            canTurnToDirection(direction, map) {
                const tileX = Math.floor(this.x / TILE_SIZE);
                const tileY = Math.floor(this.y / TILE_SIZE);
                const nextTileX = tileX + direction.x;
                const nextTileY = tileY + direction.y;
                return map.isWalkable(nextTileX, nextTileY);
            }

            // Check if Pac-Man is close enough to tile center to make a turn
            isNearTileCenter() {
                const tileX = Math.floor(this.x / TILE_SIZE);
                const tileY = Math.floor(this.y / TILE_SIZE);
                const tileCenterX = tileX * TILE_SIZE + TILE_SIZE / 2;
                const tileCenterY = tileY * TILE_SIZE + TILE_SIZE / 2;
                const threshold = this.speed + 1; // Allow some tolerance
                return Math.abs(this.x - tileCenterX) <= threshold &&
                    Math.abs(this.y - tileCenterY) <= threshold;
            }

            // Snap to tile center (for perpendicular turns)
            snapToTileCenter(axis) {
                const tileX = Math.floor(this.x / TILE_SIZE);
                const tileY = Math.floor(this.y / TILE_SIZE);
                if (axis === 'x' || axis === 'both') {
                    this.x = tileX * TILE_SIZE + TILE_SIZE / 2;
                }
                if (axis === 'y' || axis === 'both') {
                    this.y = tileY * TILE_SIZE + TILE_SIZE / 2;
                }
            }

            getDirectionName(dir) {
                if (dir === DIRECTIONS.UP) return 'UP';
                if (dir === DIRECTIONS.DOWN) return 'DOWN';
                if (dir === DIRECTIONS.LEFT) return 'LEFT';
                if (dir === DIRECTIONS.RIGHT) return 'RIGHT';
                return 'NONE';
            }

            setDirection(direction, map) {
                const reqDirName = this.getDirectionName(direction);
                const currDirName = this.getDirectionName(this.direction);


                // Check if this is a 180-degree turn (opposite direction) - always allow reversal
                const isOpposite = (
                    (this.direction === DIRECTIONS.UP && direction === DIRECTIONS.DOWN) ||
                    (this.direction === DIRECTIONS.DOWN && direction === DIRECTIONS.UP) ||
                    (this.direction === DIRECTIONS.LEFT && direction === DIRECTIONS.RIGHT) ||
                    (this.direction === DIRECTIONS.RIGHT && direction === DIRECTIONS.LEFT)
                );

                if (isOpposite) {
                    // Immediately reverse direction

                    this.direction = direction;
                    this.nextDirection = DIRECTIONS.NONE;
                } else if (this.direction === DIRECTIONS.NONE) {
                    // Starting from standstill - only set direction if we can actually move that way
                    const canMove = map && this.canMove(direction, map);

                    if (canMove) {
                        this.direction = direction;
                    } else {
                        // Buffer it for when we can move
                        this.nextDirection = direction;
                    }
                } else {
                    // Buffer the direction change for when a valid path opens

                    this.nextDirection = direction;
                }
            }

            getTilePosition() {
                return {
                    x: Math.floor(this.x / TILE_SIZE),
                    y: Math.floor(this.y / TILE_SIZE)
                };
            }

            draw(ctx) {
                ctx.fillStyle = COLORS.PACMAN;
                ctx.beginPath();

                // Calculate rotation based on direction
                let rotation = 0;
                if (this.direction === DIRECTIONS.RIGHT) rotation = 0;
                else if (this.direction === DIRECTIONS.DOWN) rotation = Math.PI / 2;
                else if (this.direction === DIRECTIONS.LEFT) rotation = Math.PI;
                else if (this.direction === DIRECTIONS.UP) rotation = -Math.PI / 2;

                // Draw Pac-Man with animated mouth
                const startAngle = rotation + this.mouthAngle;
                const endAngle = rotation + (Math.PI * 2) - this.mouthAngle;

                ctx.arc(this.x, this.y, TILE_SIZE / 2 - 1, startAngle, endAngle);
                ctx.lineTo(this.x, this.y);
                ctx.closePath();
                ctx.fill();
            }
        }

        // ==================== GHOST CLASS ====================
        class Ghost {
            constructor(color, startX, startY, scatterTarget) {
                this.color = color;
                this.startX = startX;
                this.startY = startY;
                this.scatterTarget = scatterTarget;
                this.reset();
            }

            reset() {
                this.x = this.startX;
                this.y = this.startY;
                this.direction = DIRECTIONS.UP;
                this.isVulnerable = false;
                this.isReturning = false;
                this.isInHouse = true;
                this.releaseTimer = 0;
                this.speed = GHOST_SPEED;
            }

            update(map, pacman, ghosts) {
                // Debug: log ghost state every 60 frames
                if (!this._debugCounter) this._debugCounter = 0;
                this._debugCounter++;
                if (this._debugCounter % 60 === 0) {
                    console.log(`[GHOST ${this.color}] pos: (${this.x.toFixed(1)}, ${this.y.toFixed(1)}), dir: (${this.direction.x},${this.direction.y}), inHouse: ${this.isInHouse}, speed: ${this.speed}`);
                }

                // Handle ghost house release
                if (this.isInHouse) {
                    this.releaseTimer++;
                    if (this.releaseTimer > this.getReleaseDelay()) {
                        this.isInHouse = false;
                        this.y = 11 * TILE_SIZE + TILE_SIZE / 2;
                        this.x = 14 * TILE_SIZE + TILE_SIZE / 2;
                    } else {
                        // Bounce in house
                        this.y += Math.sin(this.releaseTimer * 0.1) * 0.5;
                        return;
                    }
                }

                // Determine speed based on state
                if (this.isReturning) {
                    this.speed = GHOST_RETURNING_SPEED;
                } else if (this.isVulnerable) {
                    this.speed = GHOST_VULNERABLE_SPEED;
                } else {
                    this.speed = GHOST_SPEED;
                }

                // Check if at center of tile for direction change
                const tileX = Math.floor(this.x / TILE_SIZE);
                const tileY = Math.floor(this.y / TILE_SIZE);
                const tileCenterX = tileX * TILE_SIZE + TILE_SIZE / 2;
                const tileCenterY = tileY * TILE_SIZE + TILE_SIZE / 2;

                // Use a smaller threshold (half speed) to avoid floating point issues
                // that cause ghosts to get stuck in snap-move-snap loops
                const snapThreshold = this.speed / 2;
                if (Math.abs(this.x - tileCenterX) < snapThreshold &&
                    Math.abs(this.y - tileCenterY) < snapThreshold) {
                    // Snap to center
                    this.x = tileCenterX;
                    this.y = tileCenterY;

                    // Check if returning ghost reached home
                    if (this.isReturning && tileY >= 12 && tileY <= 15 && tileX >= 11 && tileX <= 16) {
                        console.log(`[GHOST ${this.color}] REACHED HOUSE at tile (${tileX}, ${tileY})! Setting isReturning=false, isInHouse=true`);
                        this.isReturning = false;
                        this.isVulnerable = false;
                        this.isInHouse = true;
                        this.releaseTimer = 0;
                        this.direction = DIRECTIONS.UP;
                    }

                    // Choose new direction at intersections
                    this.direction = this.chooseDirection(map, pacman, ghosts);
                }

                // Move in current direction (only if we can)
                const canMoveNow = this.canMove(this.direction, map);

                // Debug: log movement attempt every 60 frames
                if (this._debugCounter % 60 === 0) {
                    console.log(`[GHOST ${this.color}] canMoveNow: ${canMoveNow}, will move by (${this.direction.x * this.speed}, ${this.direction.y * this.speed})`);
                }

                if (canMoveNow) {
                    const beforeX = this.x, beforeY = this.y;
                    this.x += this.direction.x * this.speed;
                    this.y += this.direction.y * this.speed;
                    if (this._debugCounter % 60 === 0) {
                        console.log(`[GHOST ${this.color}] MOVED: (${beforeX.toFixed(1)}, ${beforeY.toFixed(1)}) -> (${this.x.toFixed(1)}, ${this.y.toFixed(1)})`);
                    }
                } else {
                    // If blocked, try to find a new valid direction and move in it this frame
                    const oldDir = this.direction;
                    this.direction = this.chooseDirection(map, pacman, ghosts);
                    const newCanMove = this.canMove(this.direction, map);
                    console.log(`[GHOST ${this.color}] BLOCKED at (${this.x.toFixed(1)}, ${this.y.toFixed(1)}), tile (${Math.floor(this.x / TILE_SIZE)}, ${Math.floor(this.y / TILE_SIZE)}), oldDir: (${oldDir.x},${oldDir.y}), newDir: (${this.direction.x},${this.direction.y}), newCanMove: ${newCanMove}`);
                    // Actually move in the new direction this frame if possible
                    if (newCanMove) {
                        this.x += this.direction.x * this.speed;
                        this.y += this.direction.y * this.speed;
                    }
                }

                // Handle tunnel wrapping
                if (this.x < -TILE_SIZE / 2) {
                    this.x = CANVAS_WIDTH - TILE_SIZE / 2;
                } else if (this.x > CANVAS_WIDTH - TILE_SIZE / 2) {
                    this.x = -TILE_SIZE / 2;
                }
            }

            getReleaseDelay() {
                // Different release delays for different ghosts
                const delays = {
                    [COLORS.GHOST_RED]: 0,
                    [COLORS.GHOST_PINK]: 60,
                    [COLORS.GHOST_CYAN]: 180,
                    [COLORS.GHOST_ORANGE]: 300
                };
                return delays[this.color] || 0;
            }

            chooseDirection(map, pacman, ghosts) {
                const tileX = Math.floor(this.x / TILE_SIZE);
                const tileY = Math.floor(this.y / TILE_SIZE);

                // For returning ghosts, use BFS to find the path to the ghost house
                if (this.isReturning) {
                    return this.findPathToHouse(map, tileX, tileY);
                }

                // Get target position based on ghost personality
                let targetX, targetY;

                if (this.isVulnerable) {
                    // Move away from Pac-Man (random movement)
                    targetX = Math.random() * GRID_WIDTH;
                    targetY = Math.random() * GRID_HEIGHT;
                } else {
                    // Get target based on ghost type
                    const target = this.getTarget(pacman, ghosts);
                    targetX = target.x;
                    targetY = target.y;
                }

                // Find available directions (can't reverse)
                const opposite = this.getOppositeDirection();
                const directions = [DIRECTIONS.UP, DIRECTIONS.DOWN, DIRECTIONS.LEFT, DIRECTIONS.RIGHT];

                let bestDirection = this.direction;
                let bestDistance = Infinity;

                for (const dir of directions) {
                    // Can't reverse
                    if (dir === opposite) continue;

                    const nextTileX = tileX + dir.x;
                    const nextTileY = tileY + dir.y;

                    // Check if walkable
                    if (!map.isWalkable(nextTileX, nextTileY)) continue;

                    // Ghost house is only accessible when returning
                    const tile = map.getTile(nextTileX, nextTileY);
                    if (tile === 4 && !this.isReturning) continue;

                    // Calculate distance to target
                    const distance = Math.pow(nextTileX - targetX, 2) + Math.pow(nextTileY - targetY, 2);

                    if (distance < bestDistance) {
                        bestDistance = distance;
                        bestDirection = dir;
                    }
                }

                return bestDirection;
            }

            // BFS pathfinding to find the direction to the ghost house
            findPathToHouse(map, startX, startY) {
                // Target is the ghost house entrance at (13, 11) or (14, 11)
                // The actual entrance tiles (type 4) are at row 12, columns 13-14
                const targetX = 13;
                const targetY = 11;

                // Get current tile type
                const currentTile = map.getTile(startX, startY);

                // Debug logging for returning ghosts
                if (this._debugCounter % 60 === 0) {
                    console.log(`[RETURNING ${this.color}] BFS from tile (${startX}, ${startY}) type=${currentTile} targeting entrance (${targetX}, ${targetY})`);
                }

                // Special case 1: Already inside the ghost house (tile type 4)
                // Just move down toward the center to trigger respawn
                if (currentTile === 4) {
                    if (this._debugCounter % 60 === 0) {
                        console.log(`[RETURNING ${this.color}] Inside ghost house, going DOWN`);
                    }
                    return DIRECTIONS.DOWN;
                }

                // Special case 2: At the entrance row (y=11) and within the approach corridor
                // Need to navigate to columns 13-14 where the actual entrance is
                if (startY === 11 && startX >= 9 && startX <= 18) {
                    // First, navigate horizontally to the entrance columns (13-14)
                    if (startX < 13) {
                        if (this._debugCounter % 60 === 0) {
                            console.log(`[RETURNING ${this.color}] At row 11, moving RIGHT to reach entrance`);
                        }
                        return DIRECTIONS.RIGHT;
                    }
                    if (startX > 14) {
                        if (this._debugCounter % 60 === 0) {
                            console.log(`[RETURNING ${this.color}] At row 11, moving LEFT to reach entrance`);
                        }
                        return DIRECTIONS.LEFT;
                    }
                    // At columns 13 or 14, check if we can go down
                    const belowTile = map.getTile(startX, startY + 1);
                    if (this._debugCounter % 60 === 0) {
                        console.log(`[RETURNING ${this.color}] At entrance (${startX}, 11), belowTile = ${belowTile}, going DOWN`);
                    }
                    // Go down to enter the house
                    return DIRECTIONS.DOWN;
                }

                // Special case 3: Just above the entrance row (y=10), head down to row 11
                if (startY === 10 && startX >= 9 && startX <= 18) {
                    const belowTile = map.getTile(startX, startY + 1);
                    if (belowTile !== 1) {
                        if (this._debugCounter % 60 === 0) {
                            console.log(`[RETURNING ${this.color}] At row 10, moving DOWN toward entrance corridor`);
                        }
                        return DIRECTIONS.DOWN;
                    }
                }

                // BFS to find shortest path to the entrance area
                const queue = [[startX, startY, null]]; // [x, y, firstDirection]
                const visited = new Set();
                visited.add(`${startX},${startY}`);

                const directions = [
                    { dir: DIRECTIONS.UP, dx: 0, dy: -1, name: 'UP' },
                    { dir: DIRECTIONS.DOWN, dx: 0, dy: 1, name: 'DOWN' },
                    { dir: DIRECTIONS.LEFT, dx: -1, dy: 0, name: 'LEFT' },
                    { dir: DIRECTIONS.RIGHT, dx: 1, dy: 0, name: 'RIGHT' }
                ];

                // Don't reverse direction
                const opposite = this.getOppositeDirection();

                let iterations = 0;
                const maxIterations = GRID_WIDTH * GRID_HEIGHT; // Prevent infinite loops

                while (queue.length > 0 && iterations < maxIterations) {
                    iterations++;
                    const [x, y, firstDir] = queue.shift();

                    // Check if we reached the target area (entrance at row 11, columns 13-14)
                    // We target exactly the entrance columns to ensure proper entry
                    if (y === targetY && x >= 13 && x <= 14) {
                        if (this._debugCounter % 60 === 0) {
                            const dirName = firstDir === DIRECTIONS.UP ? 'UP' :
                                firstDir === DIRECTIONS.DOWN ? 'DOWN' :
                                    firstDir === DIRECTIONS.LEFT ? 'LEFT' :
                                        firstDir === DIRECTIONS.RIGHT ? 'RIGHT' : 'DOWN';
                            console.log(`[RETURNING ${this.color}] BFS found path! First direction: ${dirName}`);
                        }
                        return firstDir || DIRECTIONS.DOWN;
                    }

                    for (const { dir, dx, dy, name } of directions) {
                        const nx = x + dx;
                        const ny = y + dy;
                        const key = `${nx},${ny}`;

                        // Skip if already visited
                        if (visited.has(key)) continue;

                        // Skip if this is the first move and it would reverse direction
                        if (firstDir === null && dir === opposite) continue;

                        // Check bounds - skip tiles outside the map
                        if (nx < 0 || nx >= GRID_WIDTH || ny < 0 || ny >= GRID_HEIGHT) continue;

                        // Check if walkable (for returning ghosts, ghost house tiles are also walkable)
                        const tile = map.getTile(nx, ny);
                        if (tile === 1) continue; // Wall

                        visited.add(key);
                        // Track which direction we took first
                        queue.push([nx, ny, firstDir === null ? dir : firstDir]);
                    }
                }

                // Fallback: if no path found, log and pick any valid direction
                if (this._debugCounter % 60 === 0) {
                    console.log(`[RETURNING ${this.color}] BFS failed to find path after ${iterations} iterations!`);
                }

                for (const { dir, dx, dy, name } of directions) {
                    if (dir === opposite) continue;
                    const nx = startX + dx;
                    const ny = startY + dy;
                    if (nx < 0 || nx >= GRID_WIDTH || ny < 0 || ny >= GRID_HEIGHT) continue;
                    const tile = map.getTile(nx, ny);
                    if (tile !== 1) {
                        if (this._debugCounter % 60 === 0) {
                            console.log(`[RETURNING ${this.color}] Fallback direction: ${name}`);
                        }
                        return dir;
                    }
                }

                return this.direction;
            }


            getTarget(pacman, ghosts) {
                const pacTile = pacman.getTilePosition();

                switch (this.color) {
                    case COLORS.GHOST_RED:
                        // Blinky: Directly targets Pac-Man
                        return pacTile;

                    case COLORS.GHOST_PINK:
                        // Pinky: Targets 4 tiles ahead of Pac-Man
                        return {
                            x: pacTile.x + pacman.direction.x * 4,
                            y: pacTile.y + pacman.direction.y * 4
                        };

                    case COLORS.GHOST_CYAN:
                        // Inky: Complex targeting using Blinky's position
                        const blinky = ghosts.find(g => g.color === COLORS.GHOST_RED);
                        if (blinky) {
                            const aheadX = pacTile.x + pacman.direction.x * 2;
                            const aheadY = pacTile.y + pacman.direction.y * 2;
                            const blinkyTile = { x: Math.floor(blinky.x / TILE_SIZE), y: Math.floor(blinky.y / TILE_SIZE) };
                            return {
                                x: aheadX + (aheadX - blinkyTile.x),
                                y: aheadY + (aheadY - blinkyTile.y)
                            };
                        }
                        return pacTile;

                    case COLORS.GHOST_ORANGE:
                        // Clyde: Targets Pac-Man if far, scatters if close
                        const distToPac = Math.abs(pacTile.x - Math.floor(this.x / TILE_SIZE)) +
                            Math.abs(pacTile.y - Math.floor(this.y / TILE_SIZE));
                        if (distToPac > 8) {
                            return pacTile;
                        }
                        return this.scatterTarget;

                    default:
                        return pacTile;
                }
            }

            getOppositeDirection() {
                if (this.direction === DIRECTIONS.UP) return DIRECTIONS.DOWN;
                if (this.direction === DIRECTIONS.DOWN) return DIRECTIONS.UP;
                if (this.direction === DIRECTIONS.LEFT) return DIRECTIONS.RIGHT;
                if (this.direction === DIRECTIONS.RIGHT) return DIRECTIONS.LEFT;
                return DIRECTIONS.NONE;
            }

            canMove(direction, map) {
                // Check if ghost can move in the given direction (same logic as Pac-Man)
                const nextX = this.x + direction.x * this.speed;
                const nextY = this.y + direction.y * this.speed;

                // Get the corners of the ghost's hitbox
                const halfSize = TILE_SIZE / 2 - 2;
                const corners = [
                    { x: nextX - halfSize, y: nextY - halfSize },
                    { x: nextX + halfSize, y: nextY - halfSize },
                    { x: nextX - halfSize, y: nextY + halfSize },
                    { x: nextX + halfSize, y: nextY + halfSize }
                ];

                for (const corner of corners) {
                    const tileX = Math.floor(corner.x / TILE_SIZE);
                    const tileY = Math.floor(corner.y / TILE_SIZE);

                    // Check for wall collision
                    if (map.isWall(tileX, tileY)) {
                        return false;
                    }

                    // Ghost house tiles - only accessible when returning
                    const tile = map.getTile(tileX, tileY);
                    if (tile === 4 && !this.isReturning) {
                        return false;
                    }
                }
                return true;
            }

            makeVulnerable() {
                if (!this.isReturning) {
                    this.isVulnerable = true;
                    // Reverse direction when becoming vulnerable
                    this.direction = this.getOppositeDirection();
                }
            }

            startReturning() {
                this.isReturning = true;
                this.isVulnerable = false;
            }

            draw(ctx, flashTime = false) {
                let color = this.color;

                if (this.isReturning) {
                    // Draw just eyes when returning
                    this.drawEyes(ctx);
                    return;
                }

                if (this.isVulnerable) {
                    color = flashTime ? COLORS.GHOST_FLASH : COLORS.GHOST_VULNERABLE;
                }

                // Draw ghost body
                ctx.fillStyle = color;
                ctx.beginPath();

                // Head (semicircle)
                ctx.arc(this.x, this.y - 2, TILE_SIZE / 2 - 2, Math.PI, 0);

                // Body with wavy bottom
                const bottomY = this.y + TILE_SIZE / 2 - 4;
                ctx.lineTo(this.x + TILE_SIZE / 2 - 2, bottomY);

                // Wavy bottom
                const waveHeight = 3;
                for (let i = 3; i >= -3; i--) {
                    const waveX = this.x + i * (TILE_SIZE / 6);
                    const waveY = bottomY + (i % 2 === 0 ? 0 : waveHeight);
                    ctx.lineTo(waveX, waveY);
                }

                ctx.lineTo(this.x - TILE_SIZE / 2 + 2, bottomY);
                ctx.closePath();
                ctx.fill();

                // Draw eyes
                if (!this.isVulnerable) {
                    this.drawEyes(ctx);
                } else {
                    // Draw scared face
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(this.x - 4, this.y - 4, 2, 0, Math.PI * 2);
                    ctx.arc(this.x + 4, this.y - 4, 2, 0, Math.PI * 2);
                    ctx.fill();

                    // Squiggly mouth
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(this.x - 5, this.y + 3);
                    for (let i = 0; i < 5; i++) {
                        ctx.lineTo(this.x - 5 + i * 2.5, this.y + 3 + (i % 2 === 0 ? 0 : 2));
                    }
                    ctx.stroke();
                }
            }

            drawEyes(ctx) {
                // Eye whites
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.ellipse(this.x - 4, this.y - 3, 4, 5, 0, 0, Math.PI * 2);
                ctx.ellipse(this.x + 4, this.y - 3, 4, 5, 0, 0, Math.PI * 2);
                ctx.fill();

                // Pupils (look in movement direction)
                ctx.fillStyle = '#00f';
                const pupilOffsetX = this.direction.x * 2;
                const pupilOffsetY = this.direction.y * 2;
                ctx.beginPath();
                ctx.arc(this.x - 4 + pupilOffsetX, this.y - 3 + pupilOffsetY, 2, 0, Math.PI * 2);
                ctx.arc(this.x + 4 + pupilOffsetX, this.y - 3 + pupilOffsetY, 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // ==================== GAME CLASS ====================
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.scoreElement = document.getElementById('score');
                this.highScoreElement = document.getElementById('highScore');
                this.livesElement = document.getElementById('lives');
                this.messageElement = document.getElementById('message');

                // XP UI Elements
                this.xpFillElement = document.getElementById('xpFill');
                this.levelElement = document.getElementById('level');
                this.currentXpElement = document.getElementById('currentXp');
                this.xpNeededElement = document.getElementById('xpNeeded');
                this.activePerksElement = document.getElementById('activePerks');
                this.perkOverlay = document.getElementById('perkOverlay');
                this.perkCardsElement = document.getElementById('perkCards');
                this.waveNotification = document.getElementById('waveNotification');

                this.audio = new AudioManager();
                this.map = new GameMap();
                this.pacman = new Pacman();
                this.ghosts = this.createGhosts();

                this.score = 0;
                this.highScore = parseInt(localStorage.getItem('pacmanHighScore')) || 0;
                this.lives = 3;
                this.gameState = 'waiting'; // waiting, playing, paused, gameover, won, levelup
                this.powerPelletTimer = 0;
                this.ghostMultiplier = 1;
                this.lastChompTime = 0;

                // XP & Leveling System
                this.xp = 0;
                this.level = 1;
                this.xpToNextLevel = BASE_XP_TO_LEVEL;

                // Perk System
                this.activePerks = [];

                // Fire Trail (Trail Blazer perk)
                this.fireTrail = []; // { x, y, timestamp }

                // Magnetized Pellets (Magnetism perk)
                this.magnetizedPellets = []; // { x, y, targetX, targetY }

                // Projectiles (Bullet perk)
                this.projectiles = []; // { x, y, targetGhost, dx, dy }
                this.bulletTimer = 0;

                // Endless Scaling
                this.waveNumber = 1;
                this.baseGhostSpeed = GHOST_SPEED;

                this.highScoreElement.textContent = this.highScore;

                this.setupInput();
                this.gameLoop();
            }

            createGhosts() {
                return [
                    new Ghost(COLORS.GHOST_RED, 14 * TILE_SIZE, 11 * TILE_SIZE + TILE_SIZE / 2, { x: 25, y: 0 }),
                    new Ghost(COLORS.GHOST_PINK, 14 * TILE_SIZE, 14 * TILE_SIZE + TILE_SIZE / 2, { x: 2, y: 0 }),
                    new Ghost(COLORS.GHOST_CYAN, 12 * TILE_SIZE, 14 * TILE_SIZE + TILE_SIZE / 2, { x: 27, y: 30 }),
                    new Ghost(COLORS.GHOST_ORANGE, 16 * TILE_SIZE, 14 * TILE_SIZE + TILE_SIZE / 2, { x: 0, y: 30 })
                ];
            }

            setupInput() {
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Space') {
                        if (this.gameState === 'waiting' || this.gameState === 'gameover' || this.gameState === 'won') {
                            this.startGame();
                        }
                        e.preventDefault();
                    }

                    if (this.gameState !== 'playing') return;

                    switch (e.code) {
                        case 'ArrowUp':
                        case 'KeyW':
                            this.pacman.setDirection(DIRECTIONS.UP, this.map);
                            e.preventDefault();
                            break;
                        case 'ArrowDown':
                        case 'KeyS':
                            this.pacman.setDirection(DIRECTIONS.DOWN, this.map);
                            e.preventDefault();
                            break;
                        case 'ArrowLeft':
                        case 'KeyA':
                            this.pacman.setDirection(DIRECTIONS.LEFT, this.map);
                            e.preventDefault();
                            break;
                        case 'ArrowRight':
                        case 'KeyD':
                            this.pacman.setDirection(DIRECTIONS.RIGHT, this.map);
                            e.preventDefault();
                            break;
                    }
                });
            }

            startGame() {
                this.audio.init();
                this.map.reset();
                this.pacman.reset();
                this.ghosts = this.createGhosts();
                this.score = 0;
                this.lives = 3;
                this.gameState = 'playing';
                this.powerPelletTimer = 0;
                this.ghostMultiplier = 1;

                // Reset XP & Perks for new game
                this.xp = 0;
                this.level = 1;
                this.xpToNextLevel = BASE_XP_TO_LEVEL;
                this.activePerks = [];
                this.fireTrail = [];
                this.magnetizedPellets = [];
                this.projectiles = [];
                this.bulletTimer = 0;
                this.waveNumber = 1;
                this.baseGhostSpeed = GHOST_SPEED;

                this.updateUI();
                this.messageElement.textContent = '';
            }

            resetAfterDeath() {
                this.pacman.reset();
                this.ghosts.forEach(ghost => ghost.reset());
                this.powerPelletTimer = 0;
                this.ghostMultiplier = 1;
            }

            update() {
                if (this.gameState !== 'playing') return;

                // Update Pac-Man
                this.pacman.update(this.map);

                // ==== MAGNETISM PERK: Attract nearby pellets ====
                if (this.hasPerk('MAGNETISM')) {
                    this.updateMagnetism();
                }

                // ==== TRAIL BLAZER PERK: Leave fire trail ====
                if (this.hasPerk('TRAIL_BLAZER')) {
                    this.updateFireTrail();
                }

                // ==== BULLET PERK: Auto-shoot at ghosts ====
                if (this.hasPerk('BULLET')) {
                    this.updateBullets();
                }

                // Update and draw magnetized pellets
                this.updateMagnetizedPellets();

                // Check pellet collision
                const pacTile = this.pacman.getTilePosition();
                const pellet = this.map.eatPellet(pacTile.x, pacTile.y);

                if (pellet === 2) {
                    this.score += POINTS.PELLET;
                    this.gainXP(XP_PER_PELLET);
                    if (Date.now() - this.lastChompTime > 100) {
                        this.audio.playSound('chomp');
                        this.lastChompTime = Date.now();
                    }
                } else if (pellet === 3) {
                    this.score += POINTS.POWER_PELLET;
                    this.gainXP(XP_PER_POWER_PELLET);
                    this.audio.playSound('powerPellet');
                    this.powerPelletTimer = POWER_PELLET_DURATION;
                    this.ghostMultiplier = 1;
                    this.ghosts.forEach(ghost => ghost.makeVulnerable());
                }

                // Update power pellet timer
                if (this.powerPelletTimer > 0) {
                    this.powerPelletTimer -= 16.67; // Approximate frame time
                    if (this.powerPelletTimer <= 0) {
                        this.ghosts.forEach(ghost => {
                            if (!ghost.isReturning) {
                                ghost.isVulnerable = false;
                            }
                        });
                    }
                }

                // Update ghosts with wave-scaled speed
                const waveSpeedMultiplier = 1 + (this.waveNumber - 1) * 0.1;
                this.ghosts.forEach(ghost => {
                    ghost.speed = ghost.isReturning ? GHOST_RETURNING_SPEED :
                        ghost.isVulnerable ? GHOST_VULNERABLE_SPEED :
                            GHOST_SPEED * waveSpeedMultiplier;
                    ghost.update(this.map, this.pacman, this.ghosts);
                });

                // Update projectiles and check collisions
                this.updateProjectiles();

                // Check ghost collision with Pac-Man
                this.ghosts.forEach(ghost => {
                    if (ghost.isReturning || ghost.isInHouse) return;

                    const dx = Math.abs(this.pacman.x - ghost.x);
                    const dy = Math.abs(this.pacman.y - ghost.y);

                    if (dx < TILE_SIZE - 4 && dy < TILE_SIZE - 4) {
                        if (ghost.isVulnerable) {
                            // Eat ghost
                            ghost.startReturning();
                            this.score += POINTS.GHOST * this.ghostMultiplier;
                            this.gainXP(XP_PER_GHOST);
                            this.ghostMultiplier *= 2;
                            this.audio.playSound('eatGhost');
                        } else {
                            // Pac-Man dies
                            this.audio.playSound('death');
                            this.lives--;
                            this.fireTrail = []; // Clear fire trail on death
                            if (this.lives <= 0) {
                                this.gameOver();
                            } else {
                                this.resetAfterDeath();
                            }
                        }
                    }
                });

                // Check fire trail collision with ghosts
                if (this.hasPerk('TRAIL_BLAZER')) {
                    this.checkFireTrailCollision();
                }

                // Check win condition -> Endless scaling
                if (this.map.allPelletsEaten()) {
                    this.startNextWave();
                }

                this.updateUI();
            }

            // ==== XP SYSTEM ====
            gainXP(amount) {
                this.xp += amount;
                while (this.xp >= this.xpToNextLevel) {
                    this.xp -= this.xpToNextLevel;
                    this.level++;
                    this.xpToNextLevel = Math.floor(BASE_XP_TO_LEVEL * Math.pow(XP_LEVEL_MULTIPLIER, this.level - 1));
                    this.showPerkMenu();
                }
            }

            hasPerk(perkId) {
                return this.activePerks.includes(perkId);
            }

            // ==== PERK MENU ====
            showPerkMenu() {
                this.gameState = 'levelup';
                this.perkOverlay.style.display = 'flex';

                // Get available perks (all 3 for now, could randomize later)
                const perkList = Object.values(PERKS);

                // Clear and populate perk cards
                this.perkCardsElement.innerHTML = '';
                perkList.forEach(perk => {
                    const card = document.createElement('div');
                    const alreadyHas = this.hasPerk(perk.id);
                    card.className = `perk-card ${perk.id.toLowerCase().replace('_', '-')}${alreadyHas ? ' owned' : ''}`;
                    card.innerHTML = `
                        <div class="perk-icon">${perk.icon}</div>
                        <div class="perk-name">${perk.name}${alreadyHas ? ' ‚úì' : ''}</div>
                        <div class="perk-desc">${alreadyHas ? 'Already owned! (Bonus XP)' : perk.desc}</div>
                    `;
                    card.onclick = () => this.selectPerk(perk.id);
                    this.perkCardsElement.appendChild(card);
                });
            }

            selectPerk(perkId) {
                if (!this.hasPerk(perkId)) {
                    this.activePerks.push(perkId);
                } else {
                    // If already has perk, give bonus XP instead
                    this.xp += 25;
                }

                this.perkOverlay.style.display = 'none';
                this.gameState = 'playing';
                this.updatePerksDisplay();
            }

            updatePerksDisplay() {
                if (this.activePerks.length === 0) {
                    this.activePerksElement.textContent = 'Perks: None';
                } else {
                    const perkNames = this.activePerks.map(id => PERKS[id].icon + ' ' + PERKS[id].name);
                    this.activePerksElement.textContent = 'Perks: ' + perkNames.join(' | ');
                }
            }

            // ==== TRAIL BLAZER PERK ====
            updateFireTrail() {
                const pacTile = this.pacman.getTilePosition();
                const now = Date.now();

                // Add current position to trail (if not already there)
                const existing = this.fireTrail.find(t => t.x === pacTile.x && t.y === pacTile.y);
                if (!existing) {
                    this.fireTrail.push({ x: pacTile.x, y: pacTile.y, timestamp: now });
                }

                // Remove old trail segments
                this.fireTrail = this.fireTrail.filter(t => now - t.timestamp < FIRE_TRAIL_DURATION);
            }

            checkFireTrailCollision() {
                const now = Date.now();
                this.ghosts.forEach(ghost => {
                    if (ghost.isReturning || ghost.isInHouse) return;

                    const ghostTileX = Math.floor(ghost.x / TILE_SIZE);
                    const ghostTileY = Math.floor(ghost.y / TILE_SIZE);

                    const hitTrail = this.fireTrail.find(t => t.x === ghostTileX && t.y === ghostTileY);
                    if (hitTrail) {
                        ghost.startReturning();
                        this.score += 100;
                        this.gainXP(25);
                        this.audio.playSound('eatGhost');
                    }
                });
            }

            // ==== MAGNETISM PERK ====
            updateMagnetism() {
                const pacTile = this.pacman.getTilePosition();

                // Find pellets within radius and start moving them
                for (let dy = -MAGNETISM_RADIUS; dy <= MAGNETISM_RADIUS; dy++) {
                    for (let dx = -MAGNETISM_RADIUS; dx <= MAGNETISM_RADIUS; dx++) {
                        const tx = pacTile.x + dx;
                        const ty = pacTile.y + dy;

                        // Check if within circular radius
                        if (dx * dx + dy * dy > MAGNETISM_RADIUS * MAGNETISM_RADIUS) continue;

                        const tile = this.map.getTile(tx, ty);
                        if (tile === 2 || tile === 3) {
                            // Check if not already magnetized
                            const alreadyMagnetized = this.magnetizedPellets.find(p => p.tileX === tx && p.tileY === ty);
                            if (!alreadyMagnetized) {
                                this.magnetizedPellets.push({
                                    tileX: tx,
                                    tileY: ty,
                                    x: tx * TILE_SIZE + TILE_SIZE / 2,
                                    y: ty * TILE_SIZE + TILE_SIZE / 2,
                                    type: tile
                                });
                                // Remove from map immediately
                                this.map.grid[ty][tx] = 0;
                            }
                        }
                    }
                }
            }

            updateMagnetizedPellets() {
                const pelletsToRemove = [];

                this.magnetizedPellets.forEach((pellet, index) => {
                    // Move toward Pac-Man
                    const dx = this.pacman.x - pellet.x;
                    const dy = this.pacman.y - pellet.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 8) {
                        // Consumed!
                        pelletsToRemove.push(index);
                        this.map.pelletsEaten++;

                        if (pellet.type === 2) {
                            this.score += POINTS.PELLET;
                            this.gainXP(XP_PER_PELLET);
                        } else if (pellet.type === 3) {
                            this.score += POINTS.POWER_PELLET;
                            this.gainXP(XP_PER_POWER_PELLET);
                            this.powerPelletTimer = POWER_PELLET_DURATION;
                            this.ghostMultiplier = 1;
                            this.ghosts.forEach(ghost => ghost.makeVulnerable());
                        }

                        if (Date.now() - this.lastChompTime > 100) {
                            this.audio.playSound('chomp');
                            this.lastChompTime = Date.now();
                        }
                    } else {
                        // Move toward Pac-Man
                        const speed = 3;
                        pellet.x += (dx / dist) * speed;
                        pellet.y += (dy / dist) * speed;
                    }
                });

                // Remove consumed pellets (in reverse order to preserve indices)
                for (let i = pelletsToRemove.length - 1; i >= 0; i--) {
                    this.magnetizedPellets.splice(pelletsToRemove[i], 1);
                }
            }

            // ==== BULLET PERK ====
            updateBullets() {
                this.bulletTimer += 16.67;

                if (this.bulletTimer >= BULLET_INTERVAL) {
                    this.bulletTimer = 0;

                    // Find nearest ghost
                    let nearestGhost = null;
                    let nearestDist = Infinity;

                    this.ghosts.forEach(ghost => {
                        if (ghost.isReturning || ghost.isInHouse) return;

                        const dx = ghost.x - this.pacman.x;
                        const dy = ghost.y - this.pacman.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestGhost = ghost;
                        }
                    });

                    if (nearestGhost) {
                        // Spawn projectile
                        const dx = nearestGhost.x - this.pacman.x;
                        const dy = nearestGhost.y - this.pacman.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        this.projectiles.push({
                            x: this.pacman.x,
                            y: this.pacman.y,
                            dx: (dx / dist) * BULLET_SPEED,
                            dy: (dy / dist) * BULLET_SPEED,
                            targetGhost: nearestGhost
                        });
                    }
                }
            }

            updateProjectiles() {
                const projectilesToRemove = [];

                this.projectiles.forEach((proj, index) => {
                    // Move projectile
                    proj.x += proj.dx;
                    proj.y += proj.dy;

                    // Check collision with ghosts
                    this.ghosts.forEach(ghost => {
                        if (ghost.isReturning || ghost.isInHouse) return;

                        const dx = ghost.x - proj.x;
                        const dy = ghost.y - proj.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        if (dist < TILE_SIZE / 2) {
                            ghost.startReturning();
                            this.score += 100;
                            this.gainXP(25);
                            this.audio.playSound('eatGhost');
                            projectilesToRemove.push(index);
                        }
                    });

                    // Remove if out of bounds
                    if (proj.x < 0 || proj.x > CANVAS_WIDTH || proj.y < 0 || proj.y > CANVAS_HEIGHT) {
                        if (!projectilesToRemove.includes(index)) {
                            projectilesToRemove.push(index);
                        }
                    }
                });

                // Remove used/oob projectiles
                for (let i = projectilesToRemove.length - 1; i >= 0; i--) {
                    this.projectiles.splice(projectilesToRemove[i], 1);
                }
            }

            // ==== ENDLESS SCALING ====
            startNextWave() {
                this.waveNumber++;
                this.map.reset();
                this.pacman.reset();
                this.ghosts = this.createGhosts();
                this.fireTrail = [];
                this.magnetizedPellets = [];
                this.projectiles = [];
                this.powerPelletTimer = 0;
                this.ghostMultiplier = 1;

                // Show wave notification
                this.waveNotification.textContent = `WAVE ${this.waveNumber}`;
                this.waveNotification.style.display = 'block';
                setTimeout(() => {
                    this.waveNotification.style.display = 'none';
                }, 2000);
            }

            gameOver() {
                this.gameState = 'gameover';
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem('pacmanHighScore', this.highScore);
                    this.highScoreElement.textContent = this.highScore;
                }
                this.messageElement.textContent = 'GAME OVER\nPRESS SPACE TO RESTART';
            }

            updateUI() {
                this.scoreElement.textContent = this.score;
                this.livesElement.textContent = this.lives;

                // Update XP bar
                const xpPercent = (this.xp / this.xpToNextLevel) * 100;
                this.xpFillElement.style.width = xpPercent + '%';
                this.levelElement.textContent = this.level;
                this.currentXpElement.textContent = this.xp;
                this.xpNeededElement.textContent = this.xpToNextLevel;

                // Update perks display
                this.updatePerksDisplay();
            }

            draw() {
                // Clear canvas
                this.ctx.fillStyle = COLORS.BACKGROUND;
                this.ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                // Draw map
                this.map.draw(this.ctx);

                // ==== Draw Fire Trail (Trail Blazer perk) ====
                this.fireTrail.forEach(trail => {
                    const px = trail.x * TILE_SIZE + TILE_SIZE / 2;
                    const py = trail.y * TILE_SIZE + TILE_SIZE / 2;
                    const age = Date.now() - trail.timestamp;
                    const alpha = 1 - (age / FIRE_TRAIL_DURATION);

                    // Outer glow
                    const gradient = this.ctx.createRadialGradient(px, py, 0, px, py, TILE_SIZE / 2);
                    gradient.addColorStop(0, `rgba(255, 150, 0, ${alpha * 0.8})`);
                    gradient.addColorStop(0.5, `rgba(255, 80, 0, ${alpha * 0.5})`);
                    gradient.addColorStop(1, `rgba(255, 0, 0, 0)`);

                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.arc(px, py, TILE_SIZE / 2, 0, Math.PI * 2);
                    this.ctx.fill();

                    // Core
                    this.ctx.fillStyle = `rgba(255, 255, 100, ${alpha * 0.9})`;
                    this.ctx.beginPath();
                    this.ctx.arc(px, py, 3, 0, Math.PI * 2);
                    this.ctx.fill();
                });

                // ==== Draw Magnetized Pellets ====
                this.magnetizedPellets.forEach(pellet => {
                    this.ctx.fillStyle = COLORS.PELLET;
                    this.ctx.beginPath();
                    const size = pellet.type === 3 ? 6 : 2;
                    this.ctx.arc(pellet.x, pellet.y, size, 0, Math.PI * 2);
                    this.ctx.fill();

                    // Magnetic glow effect
                    this.ctx.fillStyle = 'rgba(0, 200, 255, 0.3)';
                    this.ctx.beginPath();
                    this.ctx.arc(pellet.x, pellet.y, size + 4, 0, Math.PI * 2);
                    this.ctx.fill();
                });

                // ==== Draw Projectiles (Bullet perk) ====
                this.projectiles.forEach(proj => {
                    // Projectile trail
                    this.ctx.strokeStyle = 'rgba(255, 255, 0, 0.5)';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.moveTo(proj.x - proj.dx * 3, proj.y - proj.dy * 3);
                    this.ctx.lineTo(proj.x, proj.y);
                    this.ctx.stroke();

                    // Projectile core
                    this.ctx.fillStyle = '#ffff00';
                    this.ctx.beginPath();
                    this.ctx.arc(proj.x, proj.y, 4, 0, Math.PI * 2);
                    this.ctx.fill();

                    // Glow
                    this.ctx.fillStyle = 'rgba(255, 200, 0, 0.4)';
                    this.ctx.beginPath();
                    this.ctx.arc(proj.x, proj.y, 7, 0, Math.PI * 2);
                    this.ctx.fill();
                });

                // Draw ghosts
                const flashTime = this.powerPelletTimer > 0 &&
                    this.powerPelletTimer < GHOST_FLASH_TIME &&
                    Math.floor(Date.now() / 150) % 2 === 0;
                this.ghosts.forEach(ghost => ghost.draw(this.ctx, flashTime));

                // Draw Pac-Man
                this.pacman.draw(this.ctx);

                // Draw "READY!" text at start
                if (this.gameState === 'waiting') {
                    this.ctx.fillStyle = '#ffff00';
                    this.ctx.font = '16px "Courier New", monospace';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('READY!', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 50);
                }

                // Draw wave number in corner
                if (this.waveNumber > 1) {
                    this.ctx.fillStyle = '#ffd700';
                    this.ctx.font = '12px "Courier New", monospace';
                    this.ctx.textAlign = 'right';
                    this.ctx.fillText(`WAVE ${this.waveNumber}`, CANVAS_WIDTH - 10, 20);
                }
            }

            gameLoop() {
                this.update();
                this.draw();
                requestAnimationFrame(() => this.gameLoop());
            }
        }

        // ==================== START GAME ====================
        window.onload = () => {
            new Game();
        };
    </script>
</body>

</html>